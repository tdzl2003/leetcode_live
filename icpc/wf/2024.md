## B

“留到最后”的人，其实就是“留到最后的数字所属的人”，因此只要考虑每个人的每个数字，如果是最后一个，它出现的频次是多少（这个数字被留到最后的概率是多少）

因此记录每个数出现的次数及它最后一次出现对应的人即可。

## C

一个比较复杂的时间日期处理题

注意其实数据范围并不大，一方面最近y年的每一天情况可以直接用 $365y$ 的数组来记录，另一方面可以滚动记录以某个日期为单位开始的每年的出游天数，然后直接找到最近的一个不符合的年度，从而计算出要在这个日期的次日去申请，最早是在哪一年申请。然后滚动 $365$ 次，选出最早的符合条件的一天即可。时间复杂度 $365y$ 

因为代码比较复杂，一方面考虑把日期转成整数处理（这里比较考验日期处理的一些常见计算和预处理技巧），一方面要注意测试边界（比如一开始就满足条件）。

## F

题目要求将一堆点分成两组，每组有n个点，两组之间的最短距离尽量的大。

考虑采取二分+并查集+背包的方法：

* 二分目标距离（更进一步，可以二分目标距离的平方，以规避精度问题）
* 低于目标距离的两个点一定属于同一组，因此建边，构成并查集，同一个集合必定属于同一组。不同集合的是否在同一组均可。
* 然后根据不同组的数量，尝试背包选出恰好n个点。

步骤一复杂度 $\Theta(lgE)$，步骤二裸写复杂度 $\Theta(N^2)$ ，步骤三复杂度用 $\Theta(N^2)$ ，足以可通过本题。

步骤二似乎也有办法优化到 $\Theta(NlgN)$ 水平（待进一步思考，可能可以联想平面最小生成树）

步骤三利用多重背包可以优化到 $\Theta(N\sqrt{N}lgN)$ （至多只有 $\Theta(\sqrt{N})$ 个不同的值）。赛中推荐写平方的写法。

总复杂度 $\Theta(N^2lgE)$ 

## I

题目要求在树上选f个节点，使得其他节点到这些节点的最远距离尽量的短。

显然可以继续使用二分查找的框架，可以二分查找+贪心：

* 二分查找目标距离D
* 从每个叶子开始向上；当不得不放置一个station的时候，放一个；返回最近一个有效的station距离 和 未被满足的最远village距离。注意要考虑village被兄弟子树上的station满足的情况。
* 不得不放置是指未被覆盖的village已经无法从parent有效到达，此时也就不必考虑其他兄弟子树的station了。
