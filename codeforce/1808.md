[比赛链接](https://codeforces.com/contest/1808)

## A

因为数据范围不是很大，考虑预处理。

一个基础的思路是把查询看做RMQ查询，但是这样较为麻烦。

考虑到lucky值只会在0到9之间，可以预处理每个lucky值的队列，然后二分查找每个lucky值是否有在范围内的数即可。

## B

首先总和为每一列的和，因此只需要分开看每一列的分数总和。

每一列的分数总和，等于每个数减去比它小的所有数的差的和。可以将该列的所有数放到数组里排序，然后迭代计算。总复杂度 $O(NMlgN)$

## C

要求lucky值最小的数字。

注意到如果我们求到的某个前缀大于l的前缀而小于r的前缀，那么后面的数字可以取任意的数，此时可以贪心总是取与最后一个数字相同的数。

因此我们除了 $l, r$ 本身之外，仅需遍历满足这样条件的数：

* 前i-1位 或者与l相等，或者与r相等
* 前i位既不等于l，又不等于r
* 从第i+1位开始，每一位都和第i位相同。

这样的数不超过 $2*18*10$ 个，可以快速的完成。

## D

变形计数问题。

考虑对所有的 $a_i, a_{i+2j} (0\lt 2j \lt k, k-1 \le 2i+2j \le 2n-k)$ ，它在统计中总是出现且恰好仅出现一次。如果他们相等，则可以为答案节约一次操作。

因此可以采用双指针对奇数位和偶数位进行计数，找到符合上述条件1的相等的对。最大的总操作数减去相等的对 就是所需的操作次数总和。

然后还要排除不符合条件2的对，在首尾分别做一次相反的双指针操作即可。
