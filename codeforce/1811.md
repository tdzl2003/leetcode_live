[比赛链接](https://codeforces.com/contest/1811)

## A

证明题。

可以证明，最佳策略是找到最高位的比 $d$ 小的数字设它在第 $i$ 位，将 $d$ 插入在这一位之前。如果没有这样的位，把 $d$ 插入在最后。

* 如果插到之后的任何一个位置，显然前 $i-1$ 个数字都和上述答案相同，而第 $i$ 个数字不如 $d$ 大。
* 如果插到之前的任何一个位置，假设为第 $j$ 位，因为 $j$ 到 $i$ 位之间都不低于 $d$ ，若其全为 $d$ ，和前述策略结果相等。 若有至少一个大于 $d$ ，设其出现在第 $k$ 位，如果插入在 $j$ 位最高位所在位置，第 $k+1$ 位为 $d$ ，而插入到 $i$ 位置，该位大于 $d$ ，所以结果没有前述策略大。

## B

数学题

因为在环上移动不消耗能量，因此只需要观察两个环相隔多远。

设最外面的环为1，最内层的环为 $\frac{n}{2}$ 。可以观察一个坐标所在的环的编号和它距离边界的最短距离直接相关，整理为公式为：

$$
min(x, y, n-x+1, n-y+1)
$$

求得两个坐标的序号 $i,j$ ，答案即为 $|i-j|$ 。

## C

贪心构造题

输入的每个数，都是原数组相邻两个数中的较大值，所以我们要确定它究竟是哪一个值。

* 如果 $b_i\gt b_{i+1}$ ，那么显然 $a_i=b_i$ 。否则，若 $a_{i+1}=b_i$ ，必有 $b_{i+1}=max(a_{i+1},a_{i+2}) \ge a_{i+1} = b_i$
* 类似的，如果 $b_i \lt b_{i-1}$ 那么显然 $a_{i+1}=b_i$ 。
* 若 $b_i=b_{i+1}$ ，可能存在多种情况，这里可以假设 $a_{i+1}=b_i=b_{i+1}$ 

根据上述结论，我们可以转化为下述贪心算法：

* 先用 $0$ 填充数组 $a$ 。然后按下标顺序遍历。
* 若 $i\gt n-2$ 或 $b_{i+1}\ge b_i$ ，令 $a_{i+1}=b_i$
* 否则，令 $a_{i}=b_i$ 

## D

贪心证明题。

设 $h=f_n, w=f_{n+1}$ ，我们总是能切下一块 $h*h$ 的正方形，把问题变形为一个 $n-1$ 的问题进行分治分解，且之后再也不会切割下 $h*h$ 的正方形。

注意到目标点四个方向上均被分割成若干矩形，这些矩形之间必然互相独立（否则就会包括目标点）

若我们不能做此操作，有 $f_{n-1}<x\le f_n$ 。 注意到此时，另一个维度上需要
组成 $f_n-1$，在斐波那契进制角度推算，可以证明至少需要 $\lfloor\frac{n}{2}\rfloor$ 次切割；而在 $w$ 的维度上，因为不能切下整块的 $f_n$ ，我们只能用 $f_{n-1}$ 以内的斐波那契数来组成 $f_{n+1}-1$ ，容易证明至少需要 $\lfloor\frac{n+1}{2}\rfloor+1$ 次切割，总计需要 $n+1$ 次切割，形成 $n+2$ 个块，不符合题目要求。

## E

数学题。

要求不能使用数字4，其实就是使用剩下的数字构成9进制数。对原数进行九进制分解，然后把所有大于等于4的数字都加一再输出即可。