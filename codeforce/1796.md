[比赛链接](https://codeforces.com/contest/1796)

A. 简单题，其实1到15是一个循环，只需要尝试这一个循环是否能够满足就行了。唯一需要处理的是，15是“FB”，有可能出现从这个B开头的序列。所以遍历到1时，如果是B开头，跳过这个B。

B. 坑人题，正常思路写出来N*M的DP被卡超时了，几番优化都没用。所以转做证明思路。

证明：问题有解，当且仅当下列一种情况出现：

* 首字母相同，或者尾字母相同。
* 有两个连续的字母相同。

可行性证明：显然第一种情况可以用a* 或者*b模板，第二种情况则是*ab* 形式的模板就可以完成。

必要性证明：如果两个情况均不满足，假设存在一个模板，这个模板必然首尾有*，且没有连续的两个字母，形如*a*b*，这样*永远比字母多，不符合要求。

C. 数学题。因为t比较大，所以考虑部分预处理。

首先根据l不断*2，看几次超过r，可以推断出集合的大小。

其次，每个集合一定每个数是前一个数的倍数，而且显然可以证明，只会是2或者3倍（如果出现4倍以上，那么它一定不是最长的）

所以预处理2倍3倍 若干次操作后在1e6以内所能达到的所有倍数，然后看每个倍数可以出现多少次：采用r整除对应的倍数，结果如果比l大，那么这个区间内的所有数都可以选做起点。

实践证明预处理涉及的数据量很小。

实际上因为 $3*3>2*2*2$ ,所以至多也只能有一个3因子出现，所以还可以进一步优化。

D. 首先预处理x<0的情况，x<0时，设x=-x, k=n-k，可等价原问题。

现在x大于等于0，那么总是可以把它尽量塞到目标范围之内，寻求最高的区段和。分两种情况：

* 区段长度小于等于k，那么每个数都增加了x，直接在所有数都增加了x的前缀和中查询k范围以内的最小值即可。
* 区段长度大于k，那么前面的每个数都减了x，然后固定增加了k个2x，在所有数都减了x的前缀和中查询k范围以外的最小值，再加上k*2x即可。

前一个区段查询可以套线段树模板，后一个查询可以也用线段树，也可以用前缀处理完成。

E. 换根DP套路题。

其实按题目要求，就是r作为根，然后一条条出去的链标记为相同颜色（相同深度不能有多个相同颜色）。

这里DP函数记录两个值，一个是当前根所在链的长度（它后续可能继续+1），一个是除了当前根以外，最短的一条链的长度。

DP合并时，如果first为0，则选另一个first 和两个second中的较小值；否则选两个first中较小的作为first，剩下的first和两个second中的较小值作为新的second。 也就是说，贪心选择一条最短的链继续延伸，并记录无法继续延伸的最短链长度。

按换根DP模拟后，DP值中的 $min(first, second)$ 就是以这个点为根的最大得分。