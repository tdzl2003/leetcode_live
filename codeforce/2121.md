[链接](https://codeforces.com/contest/2121)

## A

简单题，要经过所有点，就分三种情况讨论：

* 起点在所有点的左侧，直接一路走到右侧
* 起点在所有点的右侧，直接一路走到左侧
* 起点位于点的中间，那么需要先走到较近的一端，再回头

## B

题目很绕，本质上如果存在解，那么必然存在一个b的长度为1的解。

所以这题本质上是求：除了第一个字符和最后一个字符以外，是否能找到两个相同的字符。

这个问题有多种实现办法，其中一种办法是：

* 把除第一个和最后一个字符的字符做成一个集合
* 如果集合的元素数量小于字符串长度-2，那么有解
* 如果第一个字符 或 最后一个字符 位于集合中，那么有解

## C

给一个矩阵，把一行一列上的所有元素-1（交叉点也值减一次），问最大值的最小可能是多少

本质上可以这样转换：

* 如果原矩阵的所有最大值 都在一个十字形范围内，那么返回该最大值-1
* 否则返回该最大值-2

到这一步已经可以枚举i,j，统计最大值的数量而形成一个 $O(nm(n+m))$ 的三次方复杂度的算法。

然后稍加思考也可以在平方复杂度完成：

* 枚举行i，排除掉第i行，判断剩下的最大值是否在同一列。
    * 可以统计每一列的最大值数量，排除掉该行的时候进行动态迭代维护来实现。

总复杂度 $O(nm)$ 。

## D

构造题，要实现一个弱化的排序，让两个数组内部有序 并且对应位置有序，n最大40 而总操作数不允许超过1709。

如果把两个数组当做整体考虑，最坏情况逆序数最大为 3160 超过了要求（虽然单次操作逆序数未必只减1），所以可能需要一些构造和证明。

考虑把全局最小的元素放到 $a_1$ ，第二小的放到 $b_1$ ，总共交换次数不超过 $80$ 次，以此类推，可以证明数组满足性质，并且总交换次数不超过 $1640$ 次。

## E

依次考虑每一位的取值：如之前所有位加起来两个数相差超过2，那么总能找到一个数使当前位不同。如果相差为1，则只能和其中一个不同。

## F

符合要求的序列要满足：

* 至少包含一个x
* 不包含任何比x大的元素。

第二个条件很容易处理，将数组根据比x大的元素进行分段，每段依次计算即可。
第一个条件也很容易类似处理：将数组根据大于等于x的元素进行分段即为需要排除的组合数。

然后考虑如何计算区段和=s的总数。区段和可以表示为前缀和的差，可以使用map（或unordered_map但要警惕hack）统计指定前缀和的数量，即可边迭代边求解。

然后在这个思路框架下，分段 等价为 清空计数数组，从而让代码编写更容易。

## G

首先设 $g(s)$ 表示1的个数而 $h(s)$ 表示0的个数，那么显然有

$$
\begin{aligned}
f(s) &= max(g(s), h(s)) \\ 
&= \frac{g(s)+h(s)+|g(s)-h(s)|}{2} \\
&= \frac{len(s)+|g(s)-h(s)|}{2} \\
\end{aligned}
$$

其中 $len(s)$ 部分很容易直接采用等差数列计算，下面讨论如何求　$\sum|g(s)-h(s)|$ 

考虑迭代 $r$ ，插入一个新的字符1，可能所有的 $g(s)$ 加1，此时对已有的 $g(s)>h(s)$ 的情况总和加1 而对所有 $g(s)<h(s)$ 的情况总和减1，插入0的情况则相反。。

采用前缀和进一步变形：

$$
g(s) = g'(r)-g'(l) \\
h(s) = h'(r)-h'(l) \\
g(s)-h(s) = g'(r)-h'(r) -(g'(l)-h'(l)) \\
m(x) = g'(x)-h'(x) \\
g(s)-h(s) = m(r)-m(l)
$$

所以所有和 $g(s)$ 、$f(s)$ 相关的公式可以改为用 $m$ 表示。

于是可以迭代字符串更新 $m(r)$ 的同时，记录历史的所有 $m(l)$ 的不同值的数量，并迭代维护有多少个小于当前 $m$ 的、有多少个大于当前 $m$ 的

## H

因为要对每一个 $k$ 求解，所以框架上要对 $k$ 迭代。

* 参考NlgN的LIS算法，需要维护所有长度的LIS的最小tail（或反过来？维护每个tail的最小LIS？）
* 处理一个新的 $(l,r)$ 时，可能是一个range set：
    * 对所有 $r\ge tail$ 的，LIS增加1 但不改变 $tail$
    * 对所有 $l\ge tail$ 的，LIS增加1 且改变 $tail$

所以考虑用一个 multiset 维护所有的候选tail

* 在 $l$ 处插入一个元素
* 在 $r+1$ 处删掉一个

即可变相实现上述过程。