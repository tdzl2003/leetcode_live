[比赛链接](https://codeforces.com/contest/1797)

## A

边界处理题

隔开二者的方法有如下几种情况：

* 其中一个点在角上，用两个格子包围；或一个在边上，用三个格子包围；或用四个格子包围。
* 画出一条斜线，分割开两个格子。可以证明这条斜线总是贴着其中的一个点。

把所有情况的数量取最小即可解决此问题。

## B

注意到对称位置上如果不同，就需要修改其中一个。我们可以找出有多少对不同的，即为最小操作次数 $c$ 。

为了简化处理，避免单独处理奇数的中间行，我们可以找出有多少“个” 与它对称的位置不同的格子，然后除以2。

然后注意到，有两种情况无解：

* 操作次数不够 $k \le c $ 时无解。
* 操作次数多余时，若 $n$ 为奇数，我们可以反复操作中间一个格子消耗掉多余次数；若 $n$ 为偶数， $k \ne c \bmod 2$ 时，也无解。

## C

第一问可以问在左上角 $1,1$ 。此时根据响应的距离，范围会锁定在一个 倒L型区间中，设距离为 $a$ ，那么答案横纵坐标中有一个为 $a+1$ ：

```
L = 3
0 0 1
0 0 1
1 1 1
```

第二问问在这个倒L型的最左格。如果答案在右侧一列上，那么距离仍为 $a$ ，否则距离小于 $a$ ，我们可以得知答案。

若第二问距离仍为a，我们再在这个倒L型的最上格询问，即可得知答案。

## D

树操作题

在每个节点上缓存子树大小和总权重，并维护一个孩子的排序树，然后按题意模拟即可。

## E

注意到每个数操作的次数不超过 $\lg X$ ，因此可采用暴力方法维护区段操作：

* 用一个set维护所有不为1的下标，并对区段中的下标进行暴力模拟。变成1后，从set中移除。

然后查询2即可用线段树维护 LCA 和深度和 来计算完成。