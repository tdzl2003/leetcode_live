[比赛链接](https://codeforces.com/contest/1809)

## A

分类讨论题，不能连续操作相同的数字，所以分类讨论：

* ABCD，可以依次操作，需要4次
* AABC，可以按ABAC顺序操作，需要4次
* AABB，可以按ABAB顺序操作，需要4次
* AAAB，可以按ABABAB顺序操作，需要6次
* AAAA，无法操作，输出-1

将输入每个数字计数并对数量进行排序即可对照上述每种情况。

## B

数学题，尽管题目描述的较为复杂，但还是可以看出构造的是一个斜过来的正方形，答案为 $\lceil\sqrt{n}~\rceil -1$

## C

构造题。我们至少找到了两个有效思路：

思路一：
* 首先堆2。每堆一个增加 $i+1$ 个和为正数的子数组数量。堆到剩下的需要的正数数量不足 $i+1$ 为止。
* 因为假设剩下的数量为 $j$，此时有 $j\le i$，我们可以选择 $-1-(i-j)*2$ ，它需要加上至少 $i-j+1$ 个2后会恰好变为正数，因此补齐了剩下的$j$ 个和为正数的子数组数量。
* 之后多余的数用-1000填充即可。

插入的数正数均为2，负数不低于 $-1-n*2$ ，在题目要求范围内。

思路二：
* 每一组子数组的和，等价于两个前缀和的差。因此：
* 不出现和为0的子数组，意味着没有任何两个前缀和相等。
* 我们可以把 $k$ 贪心的分解成若干不同的 $\le n$ 的整数，至少能找到一组符合条件的分解。
* 然后我们从空数组开始，空数组的前缀和为0。
* 每次新加入一个数时：
    * 如果对 $k$ 的分解包含 $i+1$ ，那么我们选择比现有前缀和都大的一个前缀和。
    * 如果不包含，那么我们选择比现有前缀和都小的一个前缀和。
    * 根据当前的前缀和和上一个前缀和，我们总是可以计算出要插入数组的值。

该思路下，最多有 $31$ 个不同且连续的前缀和，因此每个数组元素满足 $-30 \le a_i \le 30$ 

## D

动态规划或证明题

首先，不做额外证明，我们可以使用DP在 $O(N)$ 时间解决该问题：设 $DP[i][j]$ 表示操作原字符串的前 $i$ 个字符，且最后一个字符为 $j$ 的最小代价。递推公式包含四部分：

* DP[i-1][0]->DP[i][0]：必须最后一位是0，或支付 $10^{12}+1$
* DP[i-1][1]->DP[i][1]：必须最后一位是0，或支付 $10^{12}+1$
* DP[i-2][0]->DP[i][1]: 最后两位是01，或最后两位是10且支付 $10^{12}$ 

从上述递推过程中，我们也可以看出在最优解中至多有一次0到1的转移，我们也可以进一步简化代码，遍历该转移可能出现的所有位置（可能是起点、终点、或01、10的位置），然后动态迭代的计数该转移位置之前的1的数量和之后0的数量，同样可以 $O(N)$ 的解决该问题。

两种方法，均可以做到 $O(N)$ 的时间复杂度和 $O(1)$ 的空间复杂度。

## E

算法优化题

首先，暴力的做法需要 $O(n \cdot a \cdot b)$ 的时间复杂度。我们需要对算法进行进一步的优化。

注意到如果某一次倒水如果水不足或者目标空间不足，这次倒水是不成功的，但实际上这次不成功的倒水可能让若干初始不同的状态在后续处理中变得相同。更具体的说，若某次倒水数量不足 $v_i$ ，一定倒空或者倒满了一个杯子；这次操作之后的状态，一定和另一个水的总数相同，但该次倒水数量刚好倒空或倒满一个杯子一致。

所以我们合并考虑所有 $c+d=sum$ 相同的状态，它在目标结果中处于一条斜线之上。这里列举其中一种思考角度：

* 设 $i$ 时刻的两个杯子中水的数量分别为 $e_i,f_i$, 有 $e_i+f_i=sum$。
* $v_i\gt 0$ 时倒水的数量为 $min(v_i, e_i, b-f_i)$ 。$v_i\lt 0$ 时倒水的数量为 $min(-v_i, f_i, b-e_i)$
* 考虑每次倒水都恰好成功倒了 $v_i$ 的状态，其必然满足：
    * $v_i\lt e_i, v_i < b-f_i = b-(sum-e_i) = b-sum+e_i$
        * 推出 $e_i>v_i, e_i> v_i+sum-b$ 
    * $-v_i\lt f_i = sum-e_i, -v_i \lt b-e_i$
        * 推出 $e_i<sum+v_i, e_i<b+v_i$
    * $c=e_i - \sum_{j=1}^{i-1}{-v_i} = e_i+\sum_{j=1}^{i-1}{v_i}$ 
        * 从而可以把前面关于 $e_i$ 的范围约束转变成对 $c$ 的范围约束。
* 最后，分为两种情况：
    * 若存在满足每次倒水都恰好成功倒了 $v_i$ 的 $c$ 的区间 $[c_{min}, c_{max}]$ ，该区间内可以直接通过 $c-\sum_{j=1}^{i-1}{v_i}$ 求出最终答案。而两侧的剩余区间则和对应 $c_{min}$ 或 $c_{max}$ 的结果一致。
    * 若不存在上述区间，意味着不论初始 $c$ 是多少，结果都一定一样。随便找一组进行求解即可。也可换一个角度考虑，意味着不论初始 $c$ 是多少，某一步的 $v_i$ 都一定达不到，此时也可以直接去调整那个 $v_i$ ，以确保区间至少有一个值。

## F

迭代题

首先基础的贪心策略：以所有油价都是2为基准，考虑每个价格为1的站，尽量购买满足其和其后连续2需求的油，每多买一个单位的油，就节约了1单位的成本。直到该站点买了最多 $k$ 的油为止。

我们考虑如何以 $O(1)$ 的时间从 $i$ 起点迭代到 $i+1$ 起点。这相当于在序列（只考虑出发的站点序列，不必考虑最后回到的i）中，把 $i$ 从尾部移除再添加到头部。

那么根据我们的基础策略，我们需要：

* 如果被移除的是个1，那么它所节约的所有油都不再能继续被节约。紧接着被添加到尾部，它仍然可以节约 $a_i$ 所节约的油。
* 如果被移除的是个2，它在起点位置是不能被节约的，但是它被加到尾部的时候，有可能让最近的一个1产生节约。

所以我们进行两次循环：

* 第一次考虑 $1$ 为起点时候的答案，用我们的贪心策略求出最优解，并明确记录下每个1单价的站点节约了多少的成本。
* 第二次循环进行迭代，每次将 $i$ 从头部移去，添加到尾部，根据其单价制定不同的策略。

时间复杂度 $O(n)$ 。

晋阶思考题：如果 $b_i$ 的范围不是只有1和2，怎么做？

