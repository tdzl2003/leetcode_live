[比赛链接](https://codeforces.com/contest/1428)

# F

数据范围比较大，我们寻求 $O(N)$ 的做法。

思路1（我的思路）：

考虑通过 $\sum_l f(l,r)$ 求得 $\sum_l f(l,r+1)$。我们把一段连续的 $1$ 叫做一个“区段” 。

* 若加入的是一个0，则总和不变：除了新加入的 $f(r+1,r+1)=0$ ，剩下的都等于 $f(l,r)$ 
* 否则，可以看出从某个 $l_0$ 开始， $f(l,r+1)=f(l,r)+1$ 。
    * 证明：事实上，这里分为两个部分，首先当前区段内的每个起点恰好长度加1
    * 其次注意到 $f(l,r)$ 当 $r$ 固定 $l$ 变化时是单调不降的，所以当前区段的长度加了1，会把之前一段小于当前区段长度的函数值加1 。 
* 采用单调栈可求出最近一个长度不小于当前区段的区段，从而求出 $l_0$ 。

思路2（小羊肖恩的思路）：

同样迭代 r ，记录对于当前的r，每一个l， $f(l,r)$ 不同取值的数量。

* 若加入的是一个0，取值为0的数量+1
* 若加入的是一个1，设最后一个区段的1的数量为 curr ，则：
    * 对于所有之前取值为 $curr-1$ 的 $l$ ，取值恰好都变为 $curr$ 
    * 取值为 $1$ 至 $curr-2$ 的，取值加1；然后补充一个取值为 $1$ 的；因为这些取值的数量都恰好为1，所以该过程可以等价简化为：
        * 补充一个取值为 $curr-1$ 的

        
