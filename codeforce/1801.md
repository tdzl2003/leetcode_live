[比赛链接](https://codeforces.com/contest/1801)

## A

构造题

考虑每个二进制位的分布。从行上，第一个二进制位每1行变化一次，第二个二进制位每2行变化一次，以此类推。
从列上同样选择不同的二进制位。这样可以构造出任意两格均不同，总计需要 $\lceil\lg{200}\rceil*2=16$个二进制位。

更进一步，可以看出上述构造出来的矩阵其实就等于 $a_{i,j} = i~\mathrm{or}~(j~\mathrm{shl}~k)$ 其中 $k$ 是满足 $2^k\ge N$的最小 $k$ 。

## B

思路题

按从大到小考虑每个数，或者选择该数，最优解是它和另外一方最大值的差，或者不选择该数，必然选择对应的另一个数。
终结条件：

* 如果当前最大数所对应的另一个数已经被排除，这个数必选，可以停止循环。
* 如果一方的所有数都比另一方大，那么最小的一个数也是必选，可以停止循环。

注意如果对面就是对方最大值，需要排除这个最大值，选择对方的次大值。（除非对方已经被排除了，在相等的情况下可能会出现。）

## C

动态规划题

要使排序后序列具有最长上升子序列

首先可以预处理每个子数组，使每个子数组单调上升（移除肯定不参与贡献的元素）

然后考虑到达每个数的最优解，从最大值为该数的数组中，假设每个数为第一个参与贡献的数，可用区段max找到之前的最优解。

注意虽然值域为200000，但是t可能很大，所以不做离散化是会TLE的。

可以证明在值域上答案是单调上升的（至少可以在之前的结果上增加1），所以不用线段树，改用排序树或有序数组查询也可以通过该题。

## D

考虑每一个打工的城市：

* 它必然是已经过的城市中打工工资最高的（所有打工的城市必然是递增序列），否则就应该在上一个城市充分打工。
* 它前往下一个打工城市或者目的地必然走的是最短路

所以按打工工资顺序遍历每个城市，求得所有已到达城市中到达它的最早时间和相同时间下的最大余额（因为之前打工的城市工资不高于它，所以余额一定也低于它的打工工资。除非从起点出发的钱没花完。），即可求得到达终点的最早时间。

## E

首先考虑价格同步部分，可采用并查集，两个集合合并时，整个区段变为二者的交集。此时可以计算出总数的变少。

然后最坏情况是 $O(n*m)$ 次合并，需要思考如何减少合并操作的数量。

考虑从a到b的简单路径，即为从a向上到达ab的最近公共祖先(LCA)p，再从p向下到b

