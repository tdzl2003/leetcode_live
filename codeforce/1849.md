## E

题意：对一个排列，找到有多少个连续子数组，满足最大的元素在最小的元素右边。



## F

首先读题

* 一个有两个以上元素的分组，分数是其中一对元素异或的最小值。如果只有一个元素，分值为 $2^{30}$ （这是异或不会达到的分值，所以可以当做无穷大处理）
* 要将一个集合分成两个集合，使两个集合分数中的较小值尽量大。

### 问题变形和证明

首先，把所有元素对应成图中的点，建无向完全图，两个点之间的边为对应元素的异或值。问题变形为： 将图中的顶点标记为两种不同的颜色，使连接两个相同颜色顶点的最小权值边尽量的大。

考虑二分目标值，如果我们设定一个目标值x，设法验证一个目标值x是否合法的方法为：使所有小于x的的边，都用来连接两个不同颜色的顶点。换言之，保留所有小于x的边，图必须是一个二分图。

换一种角度思考，我们按权值从小到大顺序插入所有边，如果某条边插入以后图不再是二分图了，该边就不再能作为连接两个不同颜色顶点的边，也就是该边为所能达到的最大分值。

但是总共有 $O(n^2)$ 条边，这个方法太慢了。我们不能考虑所有的边。

考虑我们插入边的过程，若某条边连接两个属于同一连通块的顶点：

* 如果这两个顶点是相同颜色的，这条边就是解。
* 如果这两个顶点连接的是不同颜色的点，这条边实际上是多余的。

所以现在来回顾下我们的整个过程：

* 我们按权值从小到大依次考虑每一条边
* 如果这条边连接两个不同的连通块，我们就使用这条边，否则我们忽略这条边
    * 我们在这里先忽视颜色问题，因为我们可以后续再考虑它是否连接了两个不同颜色的边作为一个解）。

该过程实际上就是 Kruskal 最小生成树算法，我们找到的用来连接连通块的边就是该图的最小生成树。

我们实际上可以把该过程反过来：

* 从最小生成树出发，将图划分成二分图（最小生成树的每条边都连接两个不同颜色的点），或者说，在最小生成树上以任意一点为根，深度的奇偶性来标记该点的颜色。

> 严格的证明（不感兴趣可以跳过）
> * 如果我们使用了一个最小生成树来标记所有点的颜色，假设我们得到了答案为 $x$ ，也就是存在相同颜色的边权为 $x$ 的边，假设它连接 $i,j$ 两个顶点
> * 现在我们看该边，和最小生成树上 $i$ 到 $j$ 的简单路径，这些边组成一个奇数边数的环。
> * $x$ 必然是这个环上最大权值的边，否则用 $x$替代更大权值的边，我们能得到一个更小的最小生成树。
> * 对于任何一个解，这个环上必然有一个边连接两个相同颜色的顶点，所以最佳答案不会小于 $x$ 。

所以，本题就变形成了 XOR 权值图的最小生成树的典题。

### 其中一种解法

基于 Boruvka 算法，该算法从没有边的图开始，进行若干次迭代。

每轮迭代时，对于每一个未被连接的连通分量，连接到其最小权值的外部边上，跳过在本轮中被连接了的连通分量。这样每轮迭代最坏情况下也会将所有的连通分量两两配对，因此不超过 $lg{n}$ 轮迭代。

求解一个连通分量对外的最小边，可以用这样的方法：

* 在一个 BitTrie 中维护所有的 $A_i$ 
* 对每一个连通分量，从 BitTrie 中删掉该连通分量中的所有点，然后针对连通分量中的所有点查询BitTrie中的异或最小值，最后再加回所有的点。

这样，每轮迭代的最坏情况下，对图中所有点进行了上述操作，复杂度 $O(nlgA)$ 其中A是输入大小。算法总复杂度 $O(nlgAlgn)$

### 另一种更简单的解法

直接在BitTrie上考量，在任何一个深度上，连接两个子树的边权一定大于两个子树内部的边权，因此如果按 Kruskal 的顺序构造最小生成树，连接两个子树的时候，两个子树内部一定可以各自组成一个强连通块。

所以直接在BitTrie上深度遍历，如果两个子树都非空，就找一条最小的边连接起两个子树（可以枚举其中一个子树，在另一个子树中查找）。算法在每层上处理的节点数量不超过 $O(n)$ 每层的复杂度为 $O(nlgA)$ 总复杂度 $O(nlg^2A)$
