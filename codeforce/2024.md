## C

把若干个长为2的数组拼起来，使总逆序数最低

显然每个数组之内的逆序数不可改变，只需要关注数组之间的逆序数

考虑所有数中的最小值：

* 若存在一个方案，先选择的数组不包含该最小值，那么一定能找到最小值首先出现的地方，其前一个选择的数组的两个元素均大于最小值，因此交换这两个数组 不会使总逆序数增加（有可能使逆序数下降）

所以得出定理：一定存在至少一种最优方案，保证每次选择一定选择所有数中的最小值。

在该定理前提下，具有最小值的数组中，一定优先选择另一个数更小的。

因此将原数组排序，优先排较小值，较小值相等再排较大值，即可求得最优解。

## D

如果选手一直提交，可以拿到当前题之前所有没有跳过的题分；

如果选手选择跳过这题，会丢掉这题的分数，并跳到一道没做过的题

> 跳到一道已经做过的题是没有意义的，因为本来就可以拿到该题及之前所有的分

因此问题变成：设法跳到最高的一个下标 $j$ ，尽量减少跳到它的成本。拿到 $j$ 之前剩下所有题的得分。

因此，本题的框架思路为：找到跳转到每个下标 $j$ 的最小代价（跳过的题目数量），然后遍历最高的下标 $j$ ，用之前题目的总分减去跳过的最小代价 即为所求。

此时如何合理构造数据结构来完成DP成为关键。考虑跳转的每一步之前的一步，必然从该点的左侧出发（否则上一步可以直接跳转），而到达的点必然在该点或该点的右侧，我们可以用 延迟线段树 来维护 **到达每个点的最少代价** 而非之前描述的“跳到每个点的最小代价”，这样按顺序遍历每个点作为跳板，可以知道到达它的最少代价，并连续更新它之后一个区段的最小代价，足以通过本题。

利用操作的变换，可以把延迟线段树改为普通线段树，而单点查询改为范围查询，略微优化常数。

利用“到达每个点的最少代价”的单调性，也许还能找到更优复杂度或更低常数的方法，有待后续进一步思考。