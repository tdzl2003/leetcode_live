[比赛链接](https://codeforces.com/contest/1800)

## A. Is It a Cat?

简单题，分四个循环（分别等于meow）去迭代同一个下标，要求每个循环至少迭代一次并且最后迭代到了字符串尾部。

或者设置状态机，共有五个状态，只有在最后一个状态结束字符串才合法。

## B. Count the Number of Pairs

贪心法，因为每次修改 至多只能弄出一对来，所以其实保证每次修改尽量有效即可。

记录每个字母的大写小写数量，首先能匹配的尽量匹配掉，然后剩下的一种 可以将其至多一半（向下取整）进行操作即可。

## C1/C2. Powering the Hero

贪心法。所有英雄都是一样的，所以我们可以将原问题等价为这样的问题：

* 如果是分数卡，全都保留在分数卡堆；
* 如果是英雄卡，从分数卡堆中找出最大分值的一张交给该英雄。

如果上述存在一种最大策略，那么总是可以扔掉没有被上述策略选择的卡片，即总能拿到上述策略所拿到的卡（虽然顺序可能不同），从而构成原问题的等价策略。

所以采用一个最大堆记录所有已经出现的分数，遇到英雄卡时抽走堆顶即可。

## D. Remove Two Letters

证明题。

设 $s_i$ 为从i位置拿走两个字母得到的串。

证明1： $s_i=s_{i+1}$ 当且仅当 $a_i=a_{i+2}$

显然 $s_i$ 和 $s_{i+1}$ 前后缀都完全相同，仅有 $i$ 位置前者保留了 $a_{i+2}$ ，而后者保留了 $a_{i}$ 。二者相等当且仅当这两个字符相等。

证明2： $i<j, s_i=s_j$ 当且仅当 $s_i=s_{i+1}=s_{i+2}=....=s{j}$

根据前面的证明过程，显然若 $s_i \ne s_{i+1}$ ，那么必有 $s_i[i] \ne s_{i+1}[i] = a_i=s_{j}[i]$ ，因此 $s_i \ne s_j$ 。用同样的方法可以证明后续所有连续均需相等。

因此从计数不同串的角度，若 $a_{i+2}$和 $a_i$ 不同，我们就可以增加一个计数，否则就跳过它。 或者从 $n-1$ 开始，每遇到一对 $a_{i+2}$和 $a_i$ 相同，我们就扣掉一个计数即可。

## E1/E2. Unforgivable Curse

考虑若 $i$ 位置和 $j$ 位置允许发生交换，就在他们之间连接一条无向边，那么显然字母交换仅能发生在图的连通块内部。可以证明连通块内部可以完成任意的交换。所以原问题变形为：对于每个连通块，是否原串和目标串的各字母数量都一样？

采用并查集构建连通块，并为每个连通块进行字母计数 并比较即可。

## F. Dasha and Nightmares

变形后三个条件为如下，可以证明和原问题等价：

* 至少有一个字母没有出现。（因为规定了只出现了25个不同的字母）
* 除了某个没出现的字母，其余25个字母出现的数量都是奇数。（规定了出现的字母数量都是奇数）

充分性证明：

* 有25个字母出现的数量是奇数，那么至少出现了25个字母，并且有一个字母没出现，所以总共恰好出现了25个字母。
* 仅出现了25个字母，并且个数都是奇数，所以总长度也一定是奇数。

所以准备26个哈希表，对于每个 $s_i$，其缺失的每一个字母对应的哈希表都将其计入，key是所有字母出现数量奇偶性 组成的二进制数（命名为xormask）。

而在为 $s_j$ 找匹配的目标串时，同样在其缺失的每一个字母 $c$ 对应的哈希表中，找与其 mask 除了缺失的位均相反 `maskA ^ maskB == maskAll ^ (1<<c)`  其中 `maskAll=(1<<26)-1` 

因此总复杂度为 $O(26n + \sum|S_i|)$ 。

## G. Symmetree

首先框架思路上，如果能找到某种对子树的偏序比较关系，那么排序根的所有子树，其中两两相等，如果多余一个子树，该树也必须是对称的。

然后来讨论怎样比较两颗树同构。

考虑按深度优先顺序处理子树，这样每一棵树被处理时，其子树都已经被处理了。

考虑给每个已经处理了的子树形态 一个唯一id，这样处理每一颗树时，其所有的子树都已经被赋予了唯一id，可以将其排序； 若两个树所有子树排序后依次相同，这两颗树就也同构。我们并不关心这种大小关系的实际意义。

因此按照上述顺序，每个子树的所有子树的形态id，就是它的形态特征。如果该特征曾经出现过，就赋予相同的形态id。如果没出现过，就赋予新的形态id。用map或hash表均可记录该形态，二者复杂度均可符合题目要求。