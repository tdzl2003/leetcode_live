[比赛链接](https://codeforces.com/contest/1905)

## A

证明题。

显然每行每列都至少有一个预先重建的城市才能自动重建其他城市。因此答案不小于 $min(n, m)$ 。

然后我们构造一组解证明答案不大于 $min(n,m)$ ：沿斜线连续构造，直到抵达一边后沿边界构造。该方法可以自动重建整个区域。

所以答案为 $min(n,m)$ 

## B

证明题

* 每一步操作之后，仍然都是一个树
* 若只有两个叶子节点，图为一个链，一次操作之后可以变成一个顶点。
* 若只有三个叶子节点，一定有一个点度为3，一次操作以后只能变成一个链，操作两次才能结束。
* 若有四个或更多的叶子节点，那么一定：
    * 或者有一个点度为4或更多。此时选一个最短路径经过该点的两个叶子，整条路径都能缩成一个非叶节点。减少两个叶节点。
    * 或者有两个点度为3或更多。此时选一个最短路径经过这两点的两个叶子，整条路径都可以缩成一个非叶节点，同样减少两个叶节点。

另外，可以证明一次操作至多减少两个叶节点，因为：

* 操作的路径至多包含两个叶节点
* 路径以外的叶节点在操作之后仍为叶节点。

所以需要的最少操作次数为： $\lceil\frac{x}{2}\rceil$ 其中 $x$ 为树中叶子节点的个数。

## C

首先分析问题：

* 能被操作的仅是字典序最大的子序列
* 操作的方式仅是将其顺序循环替换（最后一个字母放到最前）

我们先来看看字典序最大的子序列是怎样的：

* 选中整个序列中最大的字符（多次出现全部选中）
* 对最后一个字符之后的部分，继续选中最大的字符
* 一直到选中最后一个字符

注意操作之后，这个子序列除了被移走的最后一个字符，都仍然是接下来字典序最大的子序列。

所以反复进行该操作等价于：

* 将原数组中字典序最大的子序列逆序。

操作次数为： 原数组中字典序最大的子序列的元素个数，减去其中“最大字符”的个数。

我们可以用一个单调栈维护出“原数组中字典序最大的子序列”，然后模拟操作就可以知道最后字符串是否已经有序。时间复杂度 $\Theta(N)$ 。 偷懒的话，可以把字符串排个序看看与之前是否相等，也足以通过本题。

## D

因为要求的是排列的前缀MEX值，MEX指最小未出现的数。

所以实际上，就等于当前位置右侧的最小数（除了最后一位恒为N）。这些候选最小数组成一个升序子序列。

如果我们从排列最开头取出一个数加入到最后，它比之前的最后一个数要小，就一直向前替换。显然，在两次0被移除之间，所有其他的数至多被移除一次，因此整体复杂度仍是 $\Theta(N)$ 的。（这个过程实际上就是单调队列）

在过程中同时维护每个数作为MEX的出现次数和所有数的和，就可以在累积 $\Theta(N)$ 时间内遍历所有的N个候选答案，从中找到最大的并输出即可。

## E

首先，观察可发现，线段树下标满足 父节点下标 $p=\lfloor\frac{v}{2}\rfloor$ 。

计算LCA是困难的，但是我们可以把每个LCA的贡献分成两部分 来化解掉LCA的问题：

* 我们认为 $v-p$ 的贡献来自于自己，而 $p$ 的贡献来自于父节点，这样父节点对于所有的非空子集（而非仅LCA的子集）均产生贡献。

此时一个完美二叉树的贡献可以推出公式计算