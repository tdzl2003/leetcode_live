[比赛链接](https://codeforces.com/contest/1821)

## A

简单计数题。

出现在最开头的0表示无解；出现在最开头的?有9种选择；剩下的?都是10中选择，乘法原理求解即可。

## B

简单题。

如果有元素和之前的不同，那么它肯定在排序的范围中。找到排序的边界，并前后扩张到最长即可。

* 题目限制了必然有元素和之前的不同。如果没有限制的话，也可以贪心找到最长的递增子数组即可。

## C

基础算法题。

考虑保留每一个字母的情形，需要去掉的是若干连续的区段。

每个连续的长度为N的区段，至少需要 $\lceil\log_2{N}\rceil$ 次操作。多个区段所需操作数，是每个区段所需操作数的最大值（互不影响）。

可以采用迭代遍历，记录每一个字母上一次出现的位置，在 $O(N+|S|)$ 时间内解决。当然，$O(N\times|S|)$  也可以通过此题。

## D

贪心题。

首先从开头贪心取每个连续的区段，直到达到数量为止。

然后，长度为1的区段可能值得放弃（减少两次shift操作，最后可能只需要额外向右移一格）。长度为2以上的区段都不值得放弃。

尝试继续往右寻找区段，直到放弃所有已遍历的长度为1的区段为止，记录曾经到达的最小代价。

## E

贪心题。

注意到每对括号被移除时的分值，等于其深度。

每次移动括号时，我们总是可以将某个左括号和它自己的右括号匹配，使其原本内部所有括号深度减1。可以证明这是最优的方法。

因此记录初始的分值 和每对括号内部的括号数量，按从大到小的顺序调整括号（不用真的操作，可以直接减去对应分值）即可。

## F

母函数题

首先分析和重新表达问题，除了 $m$ 个种树点以外，剩下 $n-m$ 个空格，被分成 $m+1$ 个区段，设长度分别为 $s_i$ 。 我们要看这 $m+1$ 个区段是否合法（是否至少存在一种树倒下的方案）

当树倒下时，除了种的那一格，恰好占据某一侧的 $k$ 格，我们只关心区段是否能放的下1个或2个 $k$ 。

所以我们把每个区段分成两部分 $s_i=a_ik+b_i$ ，其中 $0\le b_i \lt k$ ，这样对于相同的 $\sum{a_i}$ 来说 $\sum{b_i}$ 可以求出， 且此时$b_i$ 的分布部分独立于 $a_i$ 的分布，可分别解决。

我们可采用多项式卷积快速幂来计算不同 $\sum{b_i}$ 的组合数：

$$
x_0=x_1=x_2=.....=x \\
B_i(x) = 1+x_i+x_i^2+...+x_i^{k-1} \\
B(x) = \prod B_i(x) = (1+x+x^2+...+x^{k-1})^{m+1}
$$

接下来我们考虑 $a_i$ 的分布情况。注意到排列合法当且仅当任意两个 $0$ 之间至少有一个 $2$ 或更大的数。

必要性：如果连续一段 $1$ 的两侧都为0，那么这一段 $1$ 无论是向左倒还是向右倒，都会压到别的树。
充分性：从任意一个0出发，其左侧的树向左倒，其右侧的树向右倒，直到遇到一个 $2$ 或更大的数位置，必然是一个合法的解。

因此我们设 $F_i(x)$ 表示前 $i$ 个区段，最近不是一个 0 跟着若干个 1，其不同 $a_i$ 总和的组合数。而 $G_i(x)$  表示前i个区段，最近是一个0 跟着若干个1，其不同 $a_i$ 总和的组合数。

那么有：

$$
\begin{aligned}
F_{i+1}(x) &= F(i)(x+x^2+...) + G(i)(x^2+x^3+...) \\
&=F(i)\frac{x}{1-x} +G(i)\frac{x^2}{1-x} \\
G_{i+1}(x) &= F(i)(1) + G(i)(x) \\
F_1 &= {x+x^2+x^3+...} = \frac{x}{1-x} \\
G_1 &= 1
\end{aligned}
$$

从上式可以推导出：

$$
F_{i+1}(x) = (F(i)+G(i)x)\frac{x}{1-x} =G_{i+1}(x)\frac{x}{1-x}
$$

且该关系对于 $F_{1},G_1$ 同样有效。

然后可以变形原式得到：

$$
\begin{aligned}
F_{i+1}(x) &= F(i)\frac{x}{1-x} + F(i)x = F(i)\frac{2x-x^2}{1-x} \\
G_{i+1}(x) &= G_i\frac{2x-x^2}{1-x}
\end{aligned}
$$

我们最终要求的是 

$$
F_{m+1}+G_{m+1} = (F_1+G_1)(\frac{2x-x^2}{1-x})^m = \frac{1}{1-x}(\frac{2x-x^2}{1-x})^m
$$

该式同样可以用多项式卷积快速幂求得。

最后我们枚举 $c = \sum a_i$， 分别计算出 $(f(c)+g(c))*b(n-m-ck)$ 并求和即可。

## F

另一种解法：组合解法，需要一些推导，结果复杂度更优。

假设所有树都尽量往左倒，我们考虑每个树倒下后占据的空间，以及它们可能所处的位置。

如果一个树前面有k的空间，它就必须往左倒（处在右端点），否则不符合前面的假设。否则都符合之前的假设

所以假设有 $x$ 个树前面有k的空间， $m-x$ 个树前面没有k的空间，就有 $2^{m-x}$ 种方法可以倒。

我们设 $a_x$ 表示指定的某 $x$ 个树前面有 $k$ 的空间，而每棵树后面都有 $k$ 的空间，则有：

$$
a_x = {n-xk-mk \choose m}
$$

其含义为，去掉 $xk+mk$ 个格子，剩下的格子中选择 $m$ 个，再给每个后面加回 $k$ 个，再给其中指定的 $x$ 个前面加回 $k$ 个。注意这个算法里，不同的选定 $x$ 个的方案之间有重叠。

然后考虑仅有某 $x$ 个树前面有 $k$ 空间的组合数，根据容斥原理依次考虑剩下元素同时也前面有 $k$ 的可能性，得到如下公式：

$$
\begin{aligned}
b_x &= a_x - a_{x+1}{m-x \choose 1} + a_{x+2}{m-x \choose 2} - ...
    &= \sum_{i=0}^{m-x}(-1)^{i}a_{x+i}{m-x \choose i}
\end{aligned}
$$

我们要求的是：

$$
\begin{aligned}
\sum_{i=0}^m2^{m-i}b_i{m \choose i} 
&= \sum_{x=0}^m\sum_{y=0}^{m-x}2^{m-x}(-1)^y{m \choose x}{m-x \choose y}a_{x+y} \\
&= \sum_{z=0}^m\sum_{y=0}^{z}(-1)^y2^{m-z+y}{m \choose z}{z \choose y}a_z \\
&= \sum_{z=0}^m2^{m-z}{m \choose z}a_z\sum_{y=0}^{z}(-2)^y{z \choose y} \\
&= \sum_{z=0}^m2^{m-z}{m \choose z}a_z(1-2)^z
\end{aligned}
$$

该式可以在 $O(n)$ 时间完成计算。