[比赛链接](https://codeforces.com/contest/1821)

## A

简单计数题。

出现在最开头的0表示无解；出现在最开头的?有9种选择；剩下的?都是10中选择，乘法原理求解即可。

## B

简单题。

如果有元素和之前的不同，那么它肯定在排序的范围中。找到排序的边界，并前后扩张到最长即可。

* 题目限制了必然有元素和之前的不同。如果没有限制的话，也可以贪心找到最长的递增子数组即可。

## C

基础算法题。

考虑保留每一个字母的情形，需要去掉的是若干连续的区段。

每个连续的长度为N的区段，至少需要 $\lceil\log_2{N}\rceil$ 次操作。多个区段所需操作数，是每个区段所需操作数的最大值（互不影响）。

可以采用迭代遍历，记录每一个字母上一次出现的位置，在 $O(N+|S|)$ 时间内解决。当然，$O(N\times|S|)$  也可以通过此题。

## D

贪心题。

首先从开头贪心取每个连续的区段，直到达到数量为止。

然后，长度为1的区段可能值得放弃（减少两次shift操作，最后可能只需要额外向右移一格）。长度为2以上的区段都不值得放弃。

尝试继续往右寻找区段，直到放弃所有已遍历的长度为1的区段为止，记录曾经到达的最小代价。

## E

贪心题。

注意到每对括号被移除时的分值，等于其深度。

每次移动括号时，我们总是可以将某个左括号和它自己的右括号匹配，使其原本内部所有括号深度减1。可以证明这是最优的方法。

因此记录初始的分值 和每对括号内部的括号数量，按从大到小的顺序调整括号（不用真的操作，可以直接减去对应分值）即可。

## F

母函数题

首先分析和重新表达问题，除了 $m$ 个种树点以外，剩下 $n-m$ 个空格，被分成 $m+1$ 个区段，设长度分别为 $s_i$ 。

当树倒下时，除了种的那一格，恰好占据某一侧的 $k$ 格，我们只关心区段是否能放的下1个或2个 $k$ 。

所以我们把每个区段分成两部分 $s_i=a_ik+b_i$ ，其中 $0\le b_i \lt k$ ，这样对于相同的 $\sum{a_i}$ 来说 $\sum{b_i}$ 可以求出， 且此时$b_i$ 的分布部分独立于 $a_i$ 的分布，可分别解决。

我们可采用多项式卷积快速幂来计算不同 $\sum{b_i}$ 的组合数：

$$
B_i(x) = 1+x+x^2+...+x^{k-1} \\
B(x) = \prod B_i(x) = (1+x+x^2+...+x^{k-1})^{m+1}
$$

接下来我们考虑 $a_i$ 的分布情况。注意到排列合法当且仅当任意两个 $0$ 之间至少有一个 $2$ 或更大的数。

必要性：如果连续一段 $1$ 的两侧都为0，那么这一段 $1$ 无论是向左倒还是向右倒，都会压到别的树。
充分性：从任意一个0出发，其左侧的树向左倒，其右侧的树向右倒，直到遇到一个 $2$ 或更大的数位置，必然是一个合法的解。

因此我们设 $F_i(x)$ 表示前 $i$ 个区段，最近不是一个 0 跟着若干个 1，其不同 $a_i$ 总和的组合数。而 $G_i(x)$  表示前i个区段，最近是一个0 跟着若干个1，其不同 $a_i$ 总和的组合数。

那么有：

$$
\begin{aligned}
F_{i+1}(x) &= F(i)(x+x^2+...) + G(i)(x^2+x^3+...) \\
&=F(i)\frac{x}{1-x} +G(i)\frac{x^2}{1-x} \\
G_{i+1}(x) &= F(i)(1) + G(i)(x) \\
F_1 &= {x+x^2+x^3+...} = \frac{x}{1-x} \\
G_1 &= 1
\end{aligned}
$$

从上式可以推导出：

$$
F_{i+1}(x) = (F(i)+G(i)x)\frac{x}{1-x} =G_{i+1}(x)\frac{x}{1-x}
$$

且该关系对于 $F_{1},G_1$ 同样有效。

然后可以变形原式得到：

$$
\begin{aligned}
F_{i+1}(x) &= F(i)\frac{x}{1-x} + F(i)x = F(i)\frac{2x-x^2}{1-x} \\
G_{i+1}(x) &= G_i\frac{2x-x^2}{1-x}
\end{aligned}
$$

我们最终要求的是 

$$
F_{m+1}+G_{m+1} = (F_1+G_1)(\frac{2x-x^2}{1-x})^m = \frac{1}{1-x}(\frac{2x-x^2}{1-x})^m
$$

该式同样可以用多项式卷积快速幂求得。

最后我们枚举 $c = \sum a_i$， 分别计算出 $(f(c)+g(c))*b(n-m-ck)$ 并求和即可。