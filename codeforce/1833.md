[比赛链接](https://codeforces.com/contest/1833)

## A

简单题，相邻的两个字母计入一个哈希表并统计不同的组合个数就可以。因为范围很小，可以用保证无碰撞的哈希表（大小为49）

时间复杂度 $O(n)$

## B

证明题。

可以证明，如果存在解，那么把a和b分别按大小排序后对应，其也是一个合法解。

证明：如果排序后第i位不合法（不妨假设 $b_i-a_i \gt k$ ），而存在一个合法的映射/排列 $P$，则：

* 若 $P_i>i$ ，则有 $b_{P_i}\ge b_i \gt a_i+k$ ，和 $b_{P_i} - a_i \le k$ 矛盾。
* 若 $P_i\lt i$ ，则 $P$ 中必存在一个j，满足 $P_j\ge i$ 且 $j < i$ 
    * 因为 $P$ 是一个排列，所以 $i$ 必然处在一个轮换中，因此数列 $P_i, P_{P_i}, ....$ 中一定存在一次首次超过或等于 $i$ 的时刻，该 $j$ 满足上述条件。
    * 因此有 $b_{P_j} > b_i >a_i+k > a_j+k$ 和 $b_{P_j}-a_j \le k$ 矛盾。

同样方法可证 $b_i-a_i \gt k$ 而存在合法的映射也不会发生。

解法上，把a的下标排序，把b排序并安排到对应下标上即可。

时间复杂度 $O(nlgn)$ 主要来自于排序。

## C

简单题。

目标所有数都需要大于0，因此只能选择保留自己，或者减去更小的数。

由此可见原数组 $a$ 中最小的数只能保留它自己，它决定了目标数组是奇数还是偶数。

然后从最小的数开始，遍历每一个数：

* 如果它的奇偶性符合目标，则直接保留它。
* 如果它的奇偶性不符合目标，需要减去一个更小的奇数。如果不存在更小的奇数，则无解。

时间复杂度 $O(nlgn)$ 主要来自于排序。

## D

边界讨论题。

良心出题人把几乎所有边界在示例数据里都给齐了。

为了达到字典序最大，首先要确保 $n$ 尽量在最前。如果 $n$ 不能做到在最前，需要让 $n-1$ 在最前。

注意到除了一开始在最开头的数，我们总是可以通过设 $r=i-1$ 来使得 $p_i$ 最后到达开头。之后枚举l的情况，考虑 $l$ 由 $r$ 开始逐步向 $1$ 迭代的过程，相当于每次从末尾取一个数插入到当前位置。所以仅当要插入的数比当前位置的数（当前位置即为原排列的最开头 $p_1$ ）更大时，才继续插入。

从示例数据中可以看出，还有另外一种边界情况：假如我们的目标数在原排列的最后，我们可以选择让 $r=n$ ，同样可以让目标数到达开头。然后用同样的方法可以确定 $l$ 。如果不想费心思理清这种方法什么时候比前一种方法更优，可以简单的把两个排列都列出来然后比较即可。

时间复杂度 $O(n)$ 。

## E

证明/边界处理题

从示例中可以看出来，是存在某些组合，它们可以互相拼接起来，也可以打散成多个组合。

考虑给每个人记住的`neighbor`建立一条边，构成一张图，则：

* 处在一个连通块中的人必然在相同的组合中。
* 如果至少3个人组成了一个环，它们的dance组合是确定的，无法加入其他人。
* 其余的情况，dance组合可以和其他的组合合并：
    * 如果只有两个人
    * 如果没有组成一个环

没有组成一个环的情况，得到的必然是一个有重复边的链。可以将链和其他的链拼接，组成一个更大的环来满足要求。

因此，需要统计图中的每个连通块，有多少个组成了3人以上的环（设为 $a$ ），有多少个链（设为 $b$ ）

则有：$ret_{min}=min(1, b) + a, ret_{max}=b+a$

时间复杂度 $O(n)$ 。

## F

类双指针+计数题

首先题意里的条件翻译后，得出结论：选中的学生必然覆盖一段连续数字。

考虑原数组排序，不改变结果，然后依次考虑原数组中的每个数：

* 如果该数等于队列里最大的数，则可以直接加入队列。可以采用乘法原理计算对应的组合数。
* 如果该数等于队列里的最大的数+1，则可以加入队列；如果队列里超过了 $m$ 个不同的数，需要出队直到恰好有 $m$ 个不同的数为止。
* 如果该数比队列里最大的数大超过1，则可以清空队列

考虑迭代中如何维护计数，有多种办法，这里列出其中一种：

* 令 $a$ 表示之前至多 $m-1$ 个分数的不同的组合数量（相当于每个分数的数量之积）， $b$ 表示当前分数的人数， $c$ 表示当前已经有的连续不同分数。 $ret$ 维护整个问题的已知解数。初始 $a\leftarrow 1, b\leftarrow 0, c\leftarrow 0, ret\leftarrow 0$
* 如果新的数等于队列里最大的数，则 $b\leftarrow b+1$ 。如果 $c=m$ ，则 $ret\leftarrow ret+a$
* 如果新的数等于队列里最大的数+1，则 $a\leftarrow a*b, b\leftarrow 1,c\leftarrow c+1$ 。 如果 $c=m+1$ ，则出队尾指针并统计数量 $d$ ,然后 $a\leftarrow a/d, c\leftarrow c-1$ 。然后如果 $c=m$ ，则 $ret\leftarrow ret+a$
* 如果该数比队列里最大的数大超过1，清空队列，$a\leftarrow 1，b\leftarrow 1, c\leftarrow 1$ 。注意可能有边界情况 $m=1$ ，这里仍然需要判断：如果 $c=m$ ，则 $ret\leftarrow ret+a$

时间复杂度 $O(n)$ 。

## G

贪心题+简单DFS

考虑一个具体的叶子节点，它只能和自己的`parent` 放在同一个branch里。同样的，一个有着两个节点的 子树，也只能和它的 `parent` 共同组成一个branch。所以我们总是可以从叶子开始持续的去掉一个个的branch来找到符合要求的解。当无法去除时，即为无解。

另外注意到树上任意三个连通节点组成的形状总是一个 branch，所以我们只需要考虑三个三个的去除 branch，不必单独计算它们的形状。

因此可以基于上述思想，构造一个递归过程，定义 $f(node)$ 表示 node 所在的子树处理后，剩下不能去除的点的个数。然后：

* 求出 $ret = 1+\sum_{child}f(child)$ ，表示子树上尚未去除的点的个数。
* 如果 $ret=3$ ，则刚好构成一个branch，可以去除当前子树到父节点的边，并返回 $0$
* 否则返回 $ret$

最后如果 $f(root)=0$ ，问题有解。否则问题无解。

可以提前判断 $n\bmod 3=0$ 但这不是必要的。

时间复杂度 $O(n)$