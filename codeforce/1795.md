A. 简单题，因为操作是可逆的，其实将B塔反过来拼在A后面得到一个串来看待问题；如果这个串没有相邻的相同颜色的地方，那么整体符合条件；如果有一处相邻相同颜色的地方，则从这个地方分开，更上面的部分逆操作到B塔即可。如果有两处相邻相同颜色的地方，那么可以证明无解。

B. 证明题。可以证明，存在解决方法，当且仅当同时存在以k开头的线段和以k结尾的线段（两个线段可以是同一个）。如果存在这样的线段，仅保留这样的线段（一条或两条），都可以使k成为ideal point。如果不存在以k结尾的线段，那么总有 $f(k)=f(k+1)$ 。如果不存在以k开头的线段，那么总有 $f(k)=f(k-1)$ ，因此k均无法成为ideal point

C. 首先等价变换问题，按每个人顺序从当前位置一路吃到最前，此时分两种情况：

* 这个人吃完所有剩余，之后的人再也吃不到这一类型
* 当前的人恰好吃掉 $b_i$ 个，吃完还有剩。

因此考虑处理每个人时，对之前所有不足 $b_i$ 的移除，超过 $b_i$ 的数量统一减去 $b_i$。每个位置最多移除一次，所以移除操作总计不超过 $O(n)$ ，但减去操作的复杂度可能会超时。减去操作总是统一的，所以用一个累加器来代替统一减去，并对应调整所有的比较操作即可。

D. 因为 $w_i>0$ ，所以没有任何理由将一个三角形全部涂成一种颜色（如果这么做了，总是能找到另一种颜色较多的一组，和其交换一个，来提升总得分）。所以每一个三角形都是2+1的颜色组合。从所有的 $n/3$ 个三角形中，选择 $n/6$ 个来让红色更多，另 $n/6$ 个让蓝色更多，这组合数可以用组合求解。

然后来讨论每一组三角形内的组合总数。每一组三角形的组合，必然能得到其中两个权值，而放弃其中一个。为了达到最高权值，放弃的权值必须是三个边权中最低的一个。但权值可能相等，所以最低权值的边可能不止一个，均可以进行选择。

每一组三角形的选择和其它三角形的选择，以及的选择独立，可以应用乘法原理求积即可。

E. 首先和之前比赛的两道打怪题类似，没有任何理由在特殊攻击之后再使用普通攻击，因此关注最小的能量消耗，等价于关注最大的特殊攻击节约的能量值。

考虑最后一击之前的形态，除了主要目标外两侧依次递减，理想情况下依次只递减1 。但是怪物不能超出自己的初始血量，所以遇到初始血量小于预期血量时，只能保留该怪物的初始血量。

上述方法是 $O(N^2)$ 的，下面来看看怎么在更低的复杂度下解决该问题。

F. 该问题求解的是“最大的可行解”，易证明是否存在可行解对于总移动步数单调，（若存在i+1步的解，i步也一定可行），因此考虑二分查找目标并验证的方法。

考虑验证的贪心方法。思路是采用dfs由叶向根遍历，遍历到每个节点时其所有后代chip都已经处理完，同时可以记录一个最长的空白路径长度。

若一个chip向下可以通过该路径走通，则贪心向下移动。否则将chip向上移动一格，在父节点再次做判断。如果chip向上移动时遇到其它的chip，则不存在可行解。

# G. Removal Sequences

证明难题+BitMask优化。

首先考虑移除的过程，每次被移除的总是度等于其所需要的度的点，而其余的点必然度大于等于其所需要的度（否则会无法移除）。该移除过程极其类似拓扑排序，因此进行联想。

我们先证明，如果图有合法解，那么任意选择操作顺序，后续一定都能完成操作（不会出现任何点的度小于其所需要的度，也不会所有的点的度都大于其所需要的度）

1. 如果存在一组之前均合法的操作顺序，使得点i的度小于所需要的的度，那么想要调整顺序得到一个合法方案，总要选择至少一个i连通的已被消除的点j放在i之后消除。但这会导致点j的度小于其所需要的度，因此又要选择一个j连通的已被消除的点k放在其后。该操作循环无法终结，因此无法调整得到一个合法方案。
2. 如果剩余一个点集，其所有点的度都大于其所需要的度，那么无论如何调整之前已被删除的点的顺序，均无法使该点集的任何点度等于其所需要的度，也不存在合法方案。

对于任意一条边的两个顶点i,j，若同时存在两个移除序列Pa和Pb，Pa中i在j前面，而Pb中j在i前面，那么：

1. 对于Pa中i之前的所有点，和Pb中j之前的所有点，移除均不依赖i和j的移除，因此一定可以找到一个序列移除这两个集合并集中的所有点，而不移除i和j。
2. 在做完上述操作后，i和j两个点的度均小于等于自己的度，因此移除其中任意一个点均会导致他们之间的边被移除，另一个点无法被移除，从而证明序列没有合法解。

因此，我们仅需进行一次模拟，即可对每一个边形成顺序约束，相当于把每条边都变成有向边，即可计算出先后关系的约束。

最后证明，在该有向图中不存在约束路径的，总是可以交换顺序移除。

考虑该有向图的每个顶点，其出度必然等于其移除需要的度，因为从它出发的点均必须比它更晚移除。

因此该有向图的任意一个拓扑排序序列都对应着一个合法的操作序列。

若两个点之间不存在i到j的路径，也不存在j到i的路径，我们总是可以先移除所有从i和j出发均不可达的点（这包括了所有能到达i和j的点，否则就和i、j之间不存在路径矛盾），之后即可任意选择先移除i或j。

所以算法上，我们在变形得到的有向图中，找到互相不存在路径的每一对点即可。它等于所有的点对，减去互相存在路径的点对。但是求互相存在的点对是 $O(N*(N+M))$的，复杂度看似超时。

官解采用bitmap进行优化，每次计算可以到达一批64个点的可达性，这样每个点的64个可达性可以表示为一个unsigned long long，之后可以使用位运算或来计算每一条边的影响，完成64倍的加速，从而解决这道题。