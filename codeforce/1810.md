[比赛链接](https://codeforces.com/contests/1810)

## A

脑筋急转弯题

可以很容易证明，答案是YES 当且仅当存在任何一个 $i$ 满足 $a_i\le i$ 。

## B

伪装成构造题的证明题。

可以证明解法是唯一的。

首先两种操作都只能得到奇数，所以任意次操作之后都仍是奇数。

然后可以发现，为了得到一个奇数 $v$ ，可能的两个 $x$ 分别为 $\frac{v-1}{2}$ 和 $\frac{v+1}{2} = \frac{v-1}{2} + 1$ ，显然这两个数中有且只有一个是奇数。

因此从目标数倒推，可以得到唯一的解。无法得到目标数当且仅当目标数是偶数。

## C

迭代遍历。

首先顺序无关是否排列，所以可以将原数组排列。得到符合条件的策略有且仅有如下两种方法：

* 删掉数组中所有数，然后加入1
* 对某个最大的数 $i$ ，删掉比它更大的所有数；对比它小的数，每个保留1个，多删少补。

因此遍历最大保留的数 $i$ ，可用迭代在均摊 $O(1)$ 时间维护之前需要删或补的数，加上后续要删掉的数，取总代价的最小值，总复杂度 $O(N)$ 。

## D

对于长度 $0\lt l\le a$ ，只需要花费一天。对于 $l \gt a$ ，花费的天数是 $\lceil\frac{l-a}{a-b}\rceil + 1$ 。

据此可以推算出对于输入的 $a,b,n$ ，当 $n=1$ 时有 $1\le l\le a$。 当 $n>1$ 时有 $(a-b)\cdot(n-2)+a+1 \le l \le (a-b)\cdot(n-1) + a$ 。维护有效的区间，并对应回答问题即可。

## E

考虑从其中某个起点出发可以到达的点作为一个连通集，此时我们将不再关注这个连通集的具体起点是谁。

显然可以想到使用并查集维护这样的连通集，但因为没有关注起点是谁，所以集合的合并是否合法需要额外的证明。

首先我们将所有强度为0的点标记并合并（它们之间总是可以任意互相到达的）。

然后我们按值从小到大的顺序遍历每个点：

* 如果一个点此时有相邻的集合满足 $|S|>a_i$，那么从该集合显然可以到达 $i$ ，可以将两者合并。
* 如果此时有任意另一个集合 $S'$ 可以从 $a_i$ 出发到达，注意到此时我们连通的集合都满足对任意的 $k\in S'$ 满足 $a_k \le a_i$ ，因此能到达 $a_i$ 时，也必然能到达 $S'$ 中的任意顶点，也可将两者合并。
* 注意到此时 $S$ 或 $S'$ 原本相邻的点中，有可能原本不满足条件，此时随着集合合并变得满足条件了。但此时我们遍历过的点 也满足 $a_k \le a_i$ ，所以一旦 $a_i$ 发生合并，其所有相邻集合的所有待合并点也可以一并合并。

所以我们遍历每个点时：

* 如果有任意一个相邻的集合满足 $|S|>a_i$ ，将 $a_i$ 加入队列
* 对队列中的所有点：
    * 将其所有相邻集合合并，并将所有相邻集合的候选合并列表中的全部元素取出加入队列。
* 否则 $a_i$ 独立成为一个集合，并加入所有相邻集合的候选合并列表。

在上述过程中，不论是遍历次数、加入或移出队列次数、加入候选合并列表的次数，都不超过 $n+m$ ，所以整体复杂度 $O(n+m)$ 

如果最后集合合并成了一个集合，那么路径存在。否则，我们也可以证明路径是不存在的。
