[比赛链接](https://codeforces.com/contest/1806)

# A

简单题，按题意做好判断即可。为了让思路更清晰，可以分两个步骤来进行，每个步骤的执行次数都大于等于0即可。

# B

脑筋急转弯证明题，思路关键在于如何构造尽量小的MEX

* 如果0的数量少于或等于 $\lceil\frac{n}{2}\rceil$ 个，那么总是可以将其间隔摆放，从而让MEX=0
* 否则，如果全是0，或者有至少有一个比1大的数，那么总是可以将0和1隔开，从而让MEX=1
* 否则，因为总有过半的0，我们可以在0之间夹杂着出现一个1，最后0后面跟一个1，再跟上其它数，这样MEX=2

所以不必考虑更大的MEX，根据上述情况分类讨论即可。

# C

分类讨论题，可以猜测数字越大越难出现异常解，可以找到所有可能的解：

* $n=1$ ，且 $p_1=p_2$
* $n=2$ ，且 $p=(2,2,2,2)$ 
* $p_i=0$
* n为偶数，且有一个数为n，其余的均为-1。这样包含n的组合为1，积为-n；不包含n的组合和为-n，积为1 。

经过枚举可以发现不存在其它的情况，并且n越大越不太可能出现新的情况。

因此将原数组排序，和上述每一组进行比较，选择最小的差异即可。

# D

组合计数题。

依次考虑每一个点，它能够产生一个向1的边 当且仅当：

* $a_{p_i-1} = 0$ ，即，连接时是向前连接
* $r_{p_i-1} = 1$ ，即，之前的连通块已经以1为根。

其中条件2 当且仅当：

* 从 0 .. i-1 都已经连接成一个连通块。
* 每次和包含1的连通块相连，都是1作为根。

这次的条件2 当且仅当：

* 对每个 $a_{p_i}=1$ ，连接后该连通块都还没有和1连接

这当且仅当：

* 对每个 $a_{p_i}=1$ ，存在一个 $j$ 满足 $j \gt i, p_j\lt p_i, a_{p_j} = 0$

考虑迭代的解决此题：

* $ans=0, valid=1$ ， $ans$ 表示最终的结果，即为输出， $valid$ 表示到目前为止所有元素都已经连通并还能保持1作为根的组合数。
* 针对每一个i，进行如下操作：

  * $ans = ans * i$ ：表示对之前所有的组合，增加最后一个元素后都变成 $i$ 个组合（对应增加的元素放在不同的i个位置，这都不会改变之前的得分），对应的得分也乘以 $i$ 。
  * 如果 $a_i=0$ ，加上该连通块能够计分的组合数 $ans = ans + validCnt$ 表示之前的所有元素都已经连通并保持1作为根的组合，都可以在该位置得到1分。
  * 如果 $a_i=0$ ， $validCnt = validCnt * i$ 表示不管该位置能不能得分，只要能顺利连通，仍然能保持1作为根。
  * 如果 $a_i=1$ ， $validCnt = validCnt * (i-1)$ 表示对前 $i$ 个元素来说，该位置不能最后一个和1相连（会导致1不再作为根）。所有validCnt的组合 最后都是将某个连通块连到1上，所以只要不最后一个合并 $i$ ，就能保证1仍然作为根。

进行如上迭代操作，可以在 $O(N)$ 时间完成所有的计算。同时将每个ans输出即可。

# E

首先，考虑暴力方法基础上做缓存，可以证明复杂度是 $O(N\sqrt{N})$ 的，但这题卡常比较严重，`unordered_map` 等缓存方法仍然可能TLE。优化方法如下：

* 数目大于 $\sqrt{N}$ 的层 不做缓存。这样的层不超过 $\sqrt{N}$ 个，不会改变时间复杂度。
* 数目小于 $\sqrt{N}$ 的层，直接建立 $s_i^2$ 数量的全哈希表，总计的空间用量同样不超过 $O(N\sqrt{N})$  。

# F

证明题。

Hint 1 解释：

* 单独考虑重复元素。
* 如果某个重复元素需要被合并，其最佳方案是总是和相同的元素合并，这样总数仅会减少 $s_i$ 。
* 所以单独提取出所有的重复元素。可以考虑移除的对象中，不同的移除重复元素的数量。当需要移除重复元素时，永远从更小的开始移除。

在接下来的过程中，只考虑无重复元素的数组。

将原问题变形如下：将原数组分为 $N-K$ 个组 $S_i$ ，得分为 $\sum{gcd(S)}$

Hint 2 解释：

**定理1**： 当 $k>0$ ，最小的元素一定在 $|S_i|>1$ 的分组。

**证明**：设最小的元素为a，如果它单独一组，那么对于 $|S_i|>1$ 的分组，设 $S_i$ 中最大的元素为b，最小的元素c，剩下元素的gcd为d，那么有：

$$
gcd(S_i) \le gcd(b, c) \le b - c < b - a \\
a+gcd(S_i) < b < b + gcd(a, d)
$$

因此用最小的元素去替换该集合中最大的元素，总能让得分更大。

注意 $gcd(S_i)<b-c$ 成立仅当 $b\ne c$ ，因此这里要求数组中没有重复元素。

Hint 3 解释：

**定理2**： $|S_i|>1$ 的分组仅有一个。

**证明**： 根据定理1，最小值a总属于某个集合。假设先操作该集合，得到的 $gcd(S_i) <a$ ，考虑剩下的序列， $gcd(S_i)$ 为新的最小值，所以若 $k>0$ ，该值应当继续操作，直到 $k=0$ 为止。

Hint 4 解释：

将最小的 $k+1$ 个元素合并是错误的，如 $4,7,8$ ，合并 $4,7$ 得分 $1+8=9$ ，而合并 $4,8$ 得分 $4+7=11$ 。因此需要修复该方案。

**定理3** 总是合并最小的 $k$ 个元素，和剩下的某一个元素。

**证明** 设 

$$
T = \{a_1, a_2, ...,a_p, a_{c_1}, a_{c_2}, ..., a_{c_t}\} \\
T' = \{a_1, a_2, ...,a_p, a_{p+1}, a_{c_1}, a_{c_2}, ..., a_{c_{t-1}}\}
$$

令 $g=gcd(T), g'=gcd(T')$ ，有： $a_{c_t}-a_{p+1} > a_{c_t} - a_{c_t-1} \ge g$

所以 $ans(T')-ans(T) = a_{c_t}-a_{p+1}+g'-g \gt g' \ge 0$