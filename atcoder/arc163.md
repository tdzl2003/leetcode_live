[比赛链接](https://atcoder.jp/contests/arc163/tasks)

## A

题意中有干扰项。

因为t严格字典升序，所以非常容易证明，问题有解 当且仅当 问题有一个 $k=2$ 的解：

* 充分性：k=2显然是个满足题目要求的解
* 必要性：对于任意一组解，将 $t_2,...t_k$ 全部连接起来，仍然是一个比 $t_1$ 字典序更大的串。

因此仅需考虑 $k=2$ ，遍历分割点，看后面的字符串是否比前面更小即可。复杂度 $O(N^2)$ 

## B

注意到修改任何其他数字，都不如直接修改 $A_1$ 或 $A_2$ 。

* 如果要将其他数字减一 以满足 $A_1\le A_i\le A_2$，同样也可以将 $A_2$ 加1。
* 类似的，如果要将其他数字加一，同样可以将 $A_1$ 减1。

因此将数组除了开头两项以外排序，采用双指针迭代 可以求出每个可能的范围，根据范围可以求出最小的操作次数。复杂度 $O(NlgN)$ 来自排序。

## C

构造题。

注意到有 

$$
\frac{1}{i} = \frac{1}{i+1} + \frac{1}{i(i+1)}
$$

我们总是可以找到最小的、 $i+1$ 和 $i(i+1)$ 都没有出现过的数，对起进行上述分解。

经过尝试就可以知道，当 $N=500$ 时，最大的数仅为 246512 ，符合题目要求。时间复杂度为 $O(N^2)$ 

因为上述操作每次增加一个数，所以可以采用预处理/缓存以优化整体时间复杂度。

## D

因为每两个点之间都有边，所以整个图强连通分量聚点后，必然形成一条偏序链。

偏序链上的每一层关系都可以表达为：

* 将所有点分成A和B两个集合，所有在两个集合之间的边都是从A指向B的。

符合条件的划分方法数为 链上顶点数+1 。多余的1可以统一去除。

因此可以采用DP解决符合条件的划分方法数，从而规避对强连通块的直接计算。集合内的边可以任意指定。

## E

证明题

先抛结论：从低到高依次考虑每连续的两位（第0位，第1位为一组，第二位，第三位为一组，依次类推）

* 有任意一组仅有一个不同的非0值，则先手必胜
* 否则先手必败

先考虑所有数仅包含最低两位的情况：

* 只有一种不同的数，显然先手将其归0即胜利
* 有两种不同的数，其中至少有一种第1位为1。 此时先手如果操作第1位，结果会变成仅有1；如果不操作第1位，结果会变成仅有 10。 无论如何先手都必败。

接着看后续两位：

* 如果只有一种不同的非0数：
    * 如果后续有任何子问题处在必胜态（某组仅有一种非0值）：
        * 或者可以同时清空该组（该组与当前组完全同步）
        * 或者总是可以让该组至少有两个不同的非0值
    * 从而让后续所有子问题都处在必败态。
* 如果有两种以上不同的非0数：
    * 操作当前组的任意一位都会让给对手必胜态，所以不能直接操作当前组
    * 完全不操作当前组的情况下，后续的组变成子问题。子问题中有任意一组处在必胜态，就可以同时操作所有必胜态的组，给对手构造必败态。
    * 如果所有的组都在必败态，任何一个操作都会把该组变为必胜态，从而让对手必胜。

因此，先手必胜 当且仅当有任意一组处在必胜态（仅有一个不同的非0值）

## F

**首先复习** [原始问题和Slope Trick](https://zhuanlan.zhihu.com/p/389740015)

> [稍有变形的问题链接](https://codeforces.com/contest/713/problem/C)

DP[i][j]表示考虑到第i个数，且该数取值为j的最少操作数。

可以推出递推公式：

$$
DP_{i,j} = min_{k\le j}DP_{i-1,k} + |a_i-j|
$$

直接迭代处理复杂度为 $O(N^2)$ 

令 $F_i(x) = f_{i,x}, G_i(x) = min_{k\le x}f_{i-1,k} = min_{k\le x}F_{i-1}(k)$ ，那么有 $F_i(x)=G_i(x) + |x-a_i|$ ，其中 $F_i,G_i$ 均为分段线性函数。

考虑每次变换：

* 由 $F_i(x)$ 求解 $G_{i+1}(x)$ ：取前缀最小值。
    * 可证明 $F_i,G_i$ 均为凸函数，从而相当于去掉斜率为0之后的部分
* 由 $G_i(x)$ 求解 $F_i(x)$ ，增加分段函数 $|x-a_i|$。

因此采用堆维护所有的分段点：

* 每次插入两个 $a_i$ （分段函数 $|x-a_i|$ 斜率变化2）
* 同时维护斜率为0处的函数值，增加 $v-a_i$（ $v$ 为堆顶，不可能小于 $a_i$ ）
* 最后弹出堆顶元素

（CF这题严格上升的实现： 给每个数减去下标。变形公式也可以得到相同的结果。但今天F题本身就不是严格上升）

[代码](https://codeforces.com/contest/713/submission/211849330)

接着讨论本题。

**重要结论** 对于所有的 $M^N$ 个序列求解，等价于对每个s，处理每个序列：把小于等于 $s$ 的都变成0，而大于 $s$ 的都变成1，最后把所有的 $s*M^N$ 个序列的结果加起来。

证明：考虑原序列在操作后得到的序列，对每个 $s$ 都同样保持单调。另外，原序列中的每个操作，如果越过了s，则在对应的01序列 $B_i$ 中也对应一个操作。

因此考虑对01序列的求解过程，函数的分段点仅会有0和1，因此可以重新表达为如下：

* 如果 $B_i$ 中该元素为0，则移除一个1，且函数值+1。如果原本没有1，什么也不做。
* 如果 $B_i$ 中该元素为1，则增加一个1。

考虑以上两类操作（忽略什么也不做的操作），其类似括号匹配，每次函数值+1 都对应着之前的一次 “增加一个1” 操作。并且在这两个操作之间，构成一个合法的括号匹配（这个过程中一直有1），其组合数为卡塔兰数。

考虑固定这两个位置之间的距离 $k$ ，其贡献为以下值的乘积：

* $N-k-1$ （可选的位置）
* $C_{\frac{k}{2}}\times [s(M-s)]^{\frac{k}{2}+1}$ 表示两个位置内部的组合数。注意原题解少写了一个括号
* $M^{N-k-2}$ 其它数字的取值。

整理成公式如下：

$$
\begin{aligned}
& \sum_{k\ is\ even} \sum_{0\le s\lt M} (N-k-1)\times C_{\frac{k}{2}}\times [s(M-s)]^{\frac{k}{2}+1} \times M^{N-k-2} \\
= & \sum_{k\ is\ even} (N-k-1)\times C_{\frac{k}{2}} \times M^{N-k-2} \times \sum_{1\le s\lt M}[s(M-s)]^{\frac{k}{2}+1}
\end{aligned}
$$

[多项式多点求值(multipoint evaluation)](https://www.csa.iisc.ac.in/~chandan/courses/CNT/notes/lec6.pdf)
[另一个讲解](https://cs.stackexchange.com/questions/60239/multi-point-evaluations-of-a-polynomial-mod-p)