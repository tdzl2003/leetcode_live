## A

简单题，按题意找到剩下数字中的最大值并和 $P_1$ 比较即可。注意 $N=1$ 的边界情况。

## B

图论简单题。

根据题意，很容易证：

* 最强的程序员一定没有败绩（换言之，如果只有一个人没有败绩，他一定是最强的程序员）
* 如果有两个以上的程序员没有败绩，一定无法确定谁是最强的程序员。

看做有向图，就相当于找没有入度的点，如果唯一，就输出该点，如果不唯一，就输出-1 。

## C

简单题

要让最大值和最小值不超过1，其实就是让所有数变成 $\lfloor\frac{S}{N}\rfloor$ 和  $\lceil\frac{S}{N}\rceil$，并且后者的数量为 $S \bmod N$ 个。

所以将数组排序，对较小的几个变成 $\lfloor\frac{S}{N}\rfloor$， 较大的几个变成 $\lceil\frac{S}{N}\rceil$ 即可。复杂度为排序的 $O(NlgN)$

采用 `kth element` 方法，可以将复杂度优化到 $O(N)$ 。

## D

构造交互题

首先每次交互只能给出 1bit 信息，所以我们不必寻求低于 $N$ 次交互的方法。

因为 $K$ 是奇数，对于前 $K+1$ 个数，我们可以这样操作：

* 使用 $K+1$ 次查询，每次查询这 $K+1$ 个数中去掉一个数。

在上述所有查询的异或结果中，前 $K+1$ 个数每个数都查询了 $K$ 次，因为K是奇数，所以这 $K+1$ 次查询结果的异或，就等于前 $K+1$ 个数的异或。

然后使用这个异或去异或每个查询的结果，就能得到前 $K+1$ 个数的完整列表。

之后取其中已知的任意 $K-1$ 个数，搭上剩下的任何一个数，就可以确定任何未知的数。

## E

首先，如果有两个连续的非1，那么一定无解，因为永远会存在两个连续的非1

然后，我们按从右往左的顺序考虑每个非1的数V（除了字符串开头）：

* 假设需要有 K 个回合消灭掉它右侧的所有数
* 这K个回合，以及消除它自己的回合，都会往它左侧添加V-1个1
* 消灭掉这 $V-1$ 个1需要的回合数为 $(K+1)\times(V-1)$
* 加上之前的 $K+1$ 个回合，从开始到消灭掉所有数为止的回合数为 $(K+1)\times V$

另外我们发现 V=1 时，也符合上述公式（仅仅增加了1个额外的回合），所以采用上述公式倒退即可。

## F

机器的用法分两类：

* 如果 $X_j=Y_j$ ，这个机器必然将一个牌反转。
* 否则， $X_j, Y_j$  两张牌，必然变成 50% 正， 50% 反（不论之前是否有其他操作）

思路上，我们把牌分为两类：

* 反面分值比正面高，我们要设法操作这张牌，我们说这张牌的操作是“正收益”的
* 正面分值比反面高，我们要设法不操作这张牌，我们说这张牌的操作是“负收益”的。

> 特别的，如果一张牌是正收益的，但是存在一个必然反转这张牌的机器，我们则总是反转它，然后把它看做负收益的。

因为牌的总数不超过40，在正收益和负收益的牌中，总有一类牌的数量少于或等于总数的一半，因此我们可以完成 $O(2^{20}*20*20)$ 的状态压缩DP：

* 首先必然选定所有连接两个正收益牌的的机器
* 如果正收益的牌比较多，我们维护所有负收益的牌的组合下的最佳收益，并依次考虑每张正收益的牌，维护其可能连带产生的负收益。
* 如果负收益的牌比较多，我们维护所有正收益的牌的组合下的最佳收益，并依次考虑每张负收益的牌，考虑选定该牌后可能连带产生的正收益。

## G

* 如果进行了B类操作后再进行A类操作，一定不能带来新的序列（状态会被还原）。
* 如果所有碟子都有石头，此时进行A类操作所直接带来的序列，和之后再进行B类操作得到的序列是重叠的。
* 所以我们仅仅考虑，若干次A类操作后从首次有碟子清空开始，进行不同次数A类操作之后，再进行B类操作能带来的新序列。

将所有碟子按石头数量排序进行观察：

* 当 $A_i$ 被清空之后， $A_{i+1}$ 清空之前，每次A类操作都会让他们的差减1，从而之后的B类操作带来一系列不同的序列。
    * 如果所有相邻元素的差都固定，那么从有碟子为空开始，能进行B操作的次数就决定了不同序列的数量。
* 如果 $A$ 是有序的，这个过程中，不会有其他的盘子被清空，所以每次A类操作都有 $N-i+1$ 个盘子提供了石头
* 假设 $A_i$ 刚被清空的时候袋子里有 $M$ 个石头， $j$ 次操作后就有 $(N-i+1)*j+M$ 个石头
* 所以这个过程产生的新序列总数为 $\sum_{j=0}^{A_{i+1}-A_i}\lfloor\frac{(N-i+1)*j+M}{N}\rfloor$

这里转换成了 Floor Sum 典题，可以使用 [类欧几里德算法](https://oiwiki.com/math/number-theory/euclidean/) （或使用[Atcode Library](https://atcoder.github.io/ac-library/production/document_en/math.html)中的 `floor_sum` ）在 $O(lgA)$ 时间求解，算法总复杂度 $O(NlgA)$

