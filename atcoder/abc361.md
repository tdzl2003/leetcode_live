## T1

简单题，按题目要求处理好数组并输出即可。

## T2

两个立方体存在交接当且仅当在每个维度上都存在交界。

## T3

实际上就是从原数组中选取 $N-K$ 个，使得他们中最大值和最小值的差尽量的小。

因此在排序后的数组中双指针处理即可找到最优解。

## T4

数据范围较小，因此可以BFS完成本题。实现细节稍微有点复杂，需要一些耐心和偷懒的技巧。

## T5

实际上如果经过所有的点回到原点，就需要遍历所有的边两次。但不要求回到原点，其实就省掉了最后一个点回到起点的路程，这个路程越长，所要求的路程就越短。

因此求树的直径，可以在 DFS 的过程中DP求得。

## T6

采用容斥原理进行计数，求： $F(i)=\lfloor\sqrt[i]{N}\rfloor$ 表示有多少个数是 $i$ 次方数

然后可以：

* (我的赛中思路)：只考虑质数次方的容斥：$result = F(2)+F(3)+F(5)+F(7)...-F(6)-F(10)-F(15)....+F(30)...$
* （更简单的思路）：定义 $G(i) = F(i)-\sum_{k=2}^{\infty}{G(ki)}$ ，有 $result=\sum_{i=1}^\infty G(i)$

两种思路实际都只需要考虑到64以内的次方。但是注意数字1需要单独处理：它是自己的任意次方，所以在容斥时会错误计算。

## T7

我赛中想到的是[思路2](https://atcoder.jp/contests/abc361/editorial/10373)。

同样采用bfs遍历，但是不是每个格子一起遍历，而是每行中的每个连续区段 一起遍历。

最初对相邻行进行双指针遍历（类似归并排序） 可以线性的遍历出相邻关系（同样也可以证明相邻关系不超过 $O(M+N)$ 个）。随后对区段进行bfs，从外部可以bfs到的区段的面积扣除掉，同时石头本身的面积扣除掉，即可得到答案。

懒得处理hash问题，使用map/set，退化到多一个 `lg` 的复杂度，仍然可以通过本题。