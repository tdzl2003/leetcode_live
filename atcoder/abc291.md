## [A - camel Case](https://atcoder.jp/contests/abc291/tasks/abc291_a)

简单题，遍历查找即可。

## [B - Trimmed Mean](https://atcoder.jp/contests/abc291/tasks/abc291_b)

简单题，按题意排序后选择中间部分求平均数输出即可。

## [C - LRUD Instructions 2](https://atcoder.jp/contests/abc291/tasks/abc291_c)

简单题，按题意模拟，并同时用哈希表或排序树记录已经出现的所有坐标，遇到重复的则输出Yes即可。

## [D - Flip Cards](https://atcoder.jp/contests/abc291/tasks/abc291_d)

DP计数题。设 $DP[i][z]$ 为第 $i$ 张牌 $z$ 面向上的所有组合数，可 $O(N)$ 递推求出

## [E - Find Permutation](https://atcoder.jp/contests/abc291/tasks/abc291_e)

图论题。考虑把 $A_{X_i} \lt B_{Y_i}$ 记做有向边 $(X_i, Y_i)$ ，考虑1到N在排列中出现的下标，显然下标排列 对应着图的任意一个拓扑排序。 所以本题等价于判断拓扑排序是否唯一。 根据拓扑排序的定义，如果每个步骤都是唯一的，那么拓扑排序唯一，否则拓扑排序不唯一。

## [F - Teleporter and Closed off](https://atcoder.jp/contests/abc291/tasks/abc291_f)

DP计数题。设 $DP[i]$ 为从起点到i位置的最短路径， $revDP[i]$ 为i位置到终点的最短路径，两个数组可用动态规划 $O(N*M)$ 求出。

然后对于每个k，可在其前方不超过M-1个点中寻找一个存在路径的点，其后方不超过M-1个点中寻找一个存在路径的点，若二者之间有边，则可得到一条越过k的路径。遍历所有合法的路径并求最短即可。这一步骤的复杂度为 $O(N*M^2)$

## [G - OR Sum](https://atcoder.jp/contests/abc291/tasks/abc291_g)

分别考虑每一位，因此可以求出该位所有1的数目，对于不同的操作次数 $k$ ，分别求出其在这一位上的所有 a|b 数量， 然后再一次遍历即可。但是直接求所有的N个不同操作次数是 $O(N^2)$的，下面将其优化到 $O(NlgN)$ ：

注意当a、b为0或1时有：

$$
a|b  = a+b-(a\\&b) = a+b-(a*b)
$$

其中每一位上的所有 $a+b$ 之和在轮换后不变，而对于不同的操作次数 $k$ ，可以用 $concat(A, A)$ 和 $reverse(B)$  进行卷积来求得所有错位 $a*b$ 之和。从而在 $O(NlgN)$ 时间完成一位的计算。