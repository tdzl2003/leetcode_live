[比赛链接](https://atcoder.jp/contests/abc294)

## A

简单题，按题意处理即可

## B

简单题，按题意模拟即可

## C

简单题，可用O(N+M)数组合并同时记录下标；直接排序下标也可通过。

## D

简单题，按题意模拟，使用map记录已呼叫对象即可查找最小下标。

## E

离散化合并，用两个下标记录当前处理到的段落，“消除”其中共同的部分（为二者长度的较小值），然后对于长度为0的递增下标。循环处理即可在 $O(N_1+N_2)$ 时间完成

## F

首先构造基础思路为二分查找，因此需要寻找低复杂度的验证方法：针对浓度X，判断是否至少有K种混合方案浓度大于X。直接考虑浓度高于某个值并不可取，因为合并后的浓度不但取决于初始浓度，还取决于体积的比例。所以要重新分析问题。

浓度大于X的方案写作如下：

$$
(100a_i+100c_j) > X * (a_i+b_i+c_j+d_j) \\
(100a_i-Xa_i-Xb_i) + (100c_j-Xc_j-Xd_j) > 0 \\
$$

因此可以将该式分离成仅和 $i$ 和 $j$ 相关的两部分。

分别将所有的 $100a_i-Xa_i-Xb_i$ 和  $100c_j-Xc_j-Xd_j$ 排序，可以在 $O(NlgN+MlgM)$ 时间内完成排序，之后即可用 $O(N+M)$ 时间统计符合的数量。

加上二分，总复杂度为 $O((NlgN+MlgM)lg S)$ 其中S是有效精度。

## G

[重链剖分](https://cp-algorithms.com/graph/hld.html#practice-problems) 下面的例题基本是原题，是时候补板子了。
[另一个原题板子](https://judge.yosupo.jp/problem/dynamic_tree_vertex_add_path_sum)

边权改点权：以0为根，点权定义为某点到其父节点的边权。

官解方法是 [欧拉序列](https://oi-wiki.org/graph/lca/#%E7%94%A8%E6%AC%A7%E6%8B%89%E5%BA%8F%E5%88%97%E8%BD%AC%E5%8C%96%E4%B8%BA-rmq-%E9%97%AE%E9%A2%98) ，用欧拉序列（记录每个点进入和退出的时间，并取其进入的时间作为下标）上的线段树（或树状数组）可以维护每个点到根的距离 $g(x)$ 。而两个点之间的距离则为 $g(u)+g(v)-2*g(lca(u,v))$

维护距离的方法：若修改某点权值，其所有子节点（即位于其进入时间和退出时间之间的节点）的权值全部相应变化。这可以用线段树或树状数组来完成。

