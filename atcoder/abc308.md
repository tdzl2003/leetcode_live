[比赛链接](https://atcoder.jp/contests/abc308/tasks)

## A

简单题，按题意判断即可

## B

简单题，按题意查找并计算即可，硬比较也没卡复杂度，可以用哈希表优化。

## C

排序题。为了规避精度问题，比较可以采用交叉乘法取代除法。

$$
\frac{A_i}{A_i+B_i} > \frac{A_j}{A_j+B_j} \\
A_i(A_j+B_j) > A_j(A_i+B_i)
$$

## D

根据题意，每个点能到达哪些相邻点是固定的，因此直接构图BFS即可判定连通性（还可找最短路）

如果题意中的单词有重复字母，可以通过拆点解决，复杂度可能会上升到 $O(NM|S|)$ 。

## E

DP转迭代

首先从DP思考，设计状态为 $DP[i][j][k]$ ，其中 $i$ 表示第 $i$ 个字母，$j\in {0,1,2}$ 分别表示以字母 `MEX` 结束， $k$ 的二进制每一位表示对应的数字是否已经出现过。DP值表示对应的组合数量，另外通过 $k$ 可以直接求出MEX值。复杂度最坏为 $O(N*3*2^3)$ 可以求解。

为了更方便的编写代码，考虑把 $DP[i]$ 转为迭代状态 $M, E$ ：

* 当`S[i]='M'` 时，维护 $M[A_i] += 1$ ，注意这里 $A_i$ 只有三种情况
* 当`S[i]='E'` 时，针对每个 $M[j]$ ，维护 $E[2^j \oplus 2^{A_i}] += M[j]$
* 当`S[i]='X'` 时，针对每个 $E[j]$ ，维护 $ret += E[j] * mex(j \oplus 2^{A_i})$

相应复杂度为 $O(N*(3+2^3))$

官方题解采用meet in middle思想，分别处理前缀和后缀中 $M$ 和 $X$ 各状态的数量，然后枚举每个 $E$。 复杂度系数大约为9。

## F

贪心证明题

构造如下贪心算法：

* 按价格从低到高顺序考虑所有商品：
    * 从符合条件的尚未使用的优惠券中，找到抵扣金额最多的并使用。

证明：

* 在每个状态下，我们总是在尝试使用抵扣金额可能使用的的优惠券
* 如果存在一个更优的方案，在某一时刻不使用金额最多的优惠券：
    * 如果该方案这一时刻不使用任何优惠券，那么将该优惠券挪至当前时刻使用，方案不会变得更差。
    * 如果该方案这一时刻使用另一优惠券，该优惠券针对价格更高的商品也同样可以使用。交换两个使用时机，方案不会变得更差。
* 因此，可以证明，至少存在一种最佳方案，符合上述贪心算法。换言之，上述贪心算法可以找到最佳方案。

将商品和优惠券分别排序后，采用优先级队列(堆)算法实现查找，时间复杂度 $O(NlgN+MlgM+NlgM)$

## G

证明题

证明如下结论：

* 最小的xor对，一定来自按大小顺序排列时，相邻的两个数。

证明：

* 设有 $a \lt b \lt c $ 
* 考虑 $a$ 和 $c$ 首个不同的二进制位， $a$ 的该位为0， $c$ 的该位为1
* 若 $b$ 的该位为0，必有 $a\oplus b \lt a\oplus c$ 。否则，必有 $b\oplus c \lt a \oplus c$ 
* 所以全局最小的异或值一定出在两个相邻的数上。

因此采用multiset或map维护每个数字的数量，并用另一个multiset 维护相邻的异或值，在插入或删除数字时，对应插入/删除 其与相邻值的异或值，并对两个相邻值 删除/插入 它们的异或值，即可。

> 基于 bittrie 也可以得到正确的算法，可以证明最小值一定出现在某个有两个节点的子树上。这个约束比相邻值更严格，但是代码复杂程度更大。

## Ex

关键思路：

* 可以证明：不需要保证额外的点不在环上，只需要保证该点不是环上与交叉点相邻的两个点。
    * 证明：如果额外的点在环上，可以通过去掉一些边，重新变成一个Q型，并且使总代价更低。

解法一：

* 运用最短路树，可在 $O(N^2)$ 时间找到“经过某点的环” 。 为了保证尾巴边不是环上相邻点，我们可以删除掉尾巴边。候选的尾巴边只有权值最低的三条边，所以只需要尝试常数次。
    * 删除尾巴点是也可行的，但证明过程依然要用到上述关键思路的结论。
* 总体时间复杂度为 $O(N^3)$

最短路树求解最小环的做法：

* 构造最短路树（从起点出发，每个点的父节点都是从起点出发最短路的上一个点）
* 为每个点标记，标记为其所在第一层子树的根节点。起点本身标记为自己。
* 再次考虑每一条**不在最短路树中的边**：
    * 若该边连接某点到起点，可能构成一个环。最小环为最短路树中的最短路加上该边。
    * 若该边连接两个不同的子树，可能构成一个环。最小环为边两侧点的最短路加上该边。

可以很容易证明正确性，因为：

* 最小环至少包含一条不在最短路树中的边（最短路树中没有环）
* 包含一条不在最短路树中的边的最小环一定是边两侧点到起点的最短路径。

解法二：

* 参考“最小环”的Floyd算法并进行拓展。
* 假设我们可以求得**排除某点后，剩下所有两点间的最短路径**（Floyd排除某点），之后我们可以枚举当前点可以到达的每个点对，根据其间的最短距离构建环，并选择剩下的最低权值的边作为尾巴。
    * 根据上述关键思路，无需考虑该边是否在环上，仅需考虑该边不是环上相邻的两点。
* 总体时间复杂度为 $O(N^3lgN)$

排除点分治的详细做法：

* 第一层分治将点集平均分成两半，Floyd顺序完成A半后分治处理B半；然后顺序完成B半后，分治处理A半。
* 总计 $lgN$ 层，每层加起来都是完整的 $O(N^3)$ Floyd。