[比赛链接](https://atcoder.jp/contests/abc308/tasks)

## A

简单题，按题意判断即可

## B

简单题，按题意查找并计算即可，硬比较也没卡复杂度，可以用哈希表优化。

## C

排序题。为了规避精度问题，比较可以采用交叉乘法取代除法。

$$
\frac{A_i}{A_i+B_i} > \frac{A_j}{A_j+B_j} \\
A_i(A_j+B_j) > A_j(A_i+B_i)
$$

## D

根据题意，每个点能到达哪些相邻点是固定的，因此直接构图BFS即可判定连通性（还可找最短路）

如果题意中的单词有重复字母，可以通过拆点解决，复杂度可能会上升到 $O(NM|S|)$ 。

## E

DP转迭代

首先从DP思考，设计状态为 $DP[i][j][k]$ ，其中 $i$ 表示第 $i$ 个字母，$j\in {0,1,2}$ 分别表示以字母 `MEX` 结束， $k$ 的二进制每一位表示对应的数字是否已经出现过。DP值表示对应的组合数量，另外通过 $k$ 可以直接求出MEX值。复杂度最坏为 $O(N*3*2^3)$ 可以求解。

为了更方便的编写代码，考虑把 $DP[i]$ 转为迭代状态 $M, E$ ：

* 当`S[i]='M'` 时，维护 $M[A_i] += 1$ ，注意这里 $A_i$ 只有三种情况
* 当`S[i]='E'` 时，针对每个 $M[j]$ ，维护 $E[j \oplus 2^{A_i}] += M[j]$
* 当`S[i]='X'` 时，针对每个 $E[j]$ ，维护 $ret += E[j] * mex(j \oplus 2^{A_i})$

相应复杂度为 $O(N*(3+2^3))$

## F

贪心证明题

构造如下贪心算法：

* 按价格从低到高顺序考虑所有商品：
    * 从符合条件的尚未使用的优惠券中，找到抵扣金额最多的并使用。

证明：

* 在每个状态下，我们总是在尝试使用抵扣金额可能使用的的优惠券
* 如果存在一个更优的方案，在某一时刻不使用金额最多的优惠券：
    * 如果该方案这一时刻不使用任何优惠券，那么将该优惠券挪至当前时刻使用，方案不会变得更差。
    * 如果该方案这一时刻使用另一优惠券，该优惠券针对价格更高的商品也同样可以使用。交换两个使用时机，方案不会变得更差。
* 因此，可以证明，至少存在一种最佳方案，符合上述贪心算法。换言之，上述贪心算法可以找到最佳方案。

## G

证明题

证明如下结论：

* 最小的xor对，一定来自按大小顺序排列时，相邻的两个数。

证明：

* 设有 $a \lt b \lt c $ 
* 考虑 $a$ 和 $c$ 首个不同的二进制位， $a$ 的该位为0， $c$ 的该位为1
* 若 $b$ 的该位为0，必有 $a\oplus b \lt a\oplus c$ 。否则，必有 $b\oplus c \lt a \oplus c$ 
* 所以全局最小的异或值一定出在两个相邻的数上。

因此采用multiset或map维护每个数字的数量，并用另一个multiset 维护相邻的异或值，在插入或删除数字时，对应插入/删除 其与相邻值的异或值，并对两个相邻值 删除/插入 它们的异或值，即可。

## Ex

（待补）
目前get到两个思路，还没彻底研究明白：

* 最短路树
* 分治解决删点问题