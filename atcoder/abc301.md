[比赛链接](https://atcoder.jp/contests/abc301)

## A

简单题，遍历并输出即可

## B

简单题，按题意要求进行内层循环输出即可

## C

思路题。

由于可以任意排序，只需要对每个字母计数，并对`@`进行额外计数，然后比较每个字母的差额并用对应的`@`抵扣，能够抵扣成功即为有解。

## D

有多种思路可以在 $O(lgN)$ 时间解决本题：

* 贪心：从最高位开始找，尽量贴近N，直到不得不小于N为止。不得不小于N包括两种情况：
    * 某一位N为1而s为0
    * 某一位N为0而s为1，此时需要找到之前最近的一个N为1而s为?的，将s变为0，之后的?全部填1
* 数位DP：仅需同时记录并维护两种状态：
    * 前缀已经比N小
    * 前缀和N相同
* DFS：只需要优先尝试1，后尝试0，当前缀比N大时返回，找到一组解后立即退出，可以证明复杂度同样为 $O(lgN)$ ，和上面的贪心思路尝试的过程一致。
* 二分：依次尝试每一个?是否可以为1，尝试方法为：将该位标为1并将后续所有?标为0，如果比N大，则该位必须为0。

## E

可分为两个阶段完成本题：

* 计算出每个`S/G/o` 点两两之间的距离，可从每个点出发BFS得到，复杂度 $O(HW|o|)$
* 采用二进制压缩DP遍历所有的拾取方案，确定要去拾取哪些糖果，复杂度 $2^{|o|}|o|^2$ 

足以通过本题。

## F

考虑构造状态机形式的DP，设计状态如下：

1. 未出现两个相同的大写字母
2. 已出现两个相同的大写字母
3. 已出现两个相同的大写字母之后一个小写字母
4. 已出现DDoS形式（排除，无需统计）

其中2、3状态的转移较容易计算，我们重点思考怎么计算1状态的数量和1状态到2状态的转移。

考虑已经出现过的大写字母，分为两种：

* 在模板串中直接写死的大写字母
* ?中出现大写字母

其中第一类我们可以采用哈希表进行统计，第二类我们如果考虑所有字母的组合，组合数量过大，因此我们仅仅区分记录?中不同大写字母的数量，并在未出现的字母中选定排列来快速计算实际的组合数量。
