[比赛链接](https://atcoder.jp/contests/arc201/tasks)

## A

简单题，考虑把每个出题人的题量分成三组：

* 只能选A的部分
* 只能选B的部分
* A和B选其一的部分

然后总量易分类讨论得出：

* 若第一部分加第三部分小于第二部分，则返回第一部分和第三部分的和
* 若第二部分加第三部分小于第一部分则类似
* 否则，取总数除以2（将第三部分尽量均匀分派）

下面讨论怎么快速的把每个出题人的题量分为三组

* 第三部分实际上等于 两种比赛各自的最大出题量，减去 两种比赛的总计出题量
    * 所以等于 max(0, min(a,b)+min(b,c)-b)
* 第一部分加第三部分=min(a,b)
* 第二部分加第三部分=min(b,c)

## B

奇怪的大范围背包题，因为weight全是2的幂，所以很容易想到要基于这个搞事情。

### 赛中思路：较复杂的max-sum卷积

先用传统的背包DP视角来考虑，每考虑一个物品的公式，是 

$$
next_i = max(dp_i, dp_{i-w}+v)
$$

如果weight全部为1，那么很容易发现算出来的DP 等价于 value 数组从大到小排序后的前缀和。（这个结论很重要）

所以分两头想：

* 先考虑weight全部为1的物品
* 然后想办法把DP数组两两压缩（等于把所有weight/2），再考虑weight为2的物品

因此几个过程分别是：

* 新物品的DP数组：将这一层的value从大到小排序，然后求前缀和，得到只用这一层物品的DP数组。
* 合并： $next_i = max\{dp1_{i-k}+dp2_{k}\}$ ，这是一个max-sum convolution问题，可以套模板。
* 压缩： 分两种情况：
    * 如果W的这一位为1，后续这一位将不再用到，所以肯定选 $DP_1, DP_3, ...$  进行压缩
    * 否则选 $DP_0, DP_2, ...$ 进行压缩

然后就可以交了，这个方法是可以通过的。

### 赛后重新想：物品合并思路

考虑相邻的两层，把下一层变形成上一层的物品

* 如果W对应位为1，下一层如果有，肯定拿1、3、5、7……个物品
    * 那么相当于第1个物品必拿，第2、3个物品合并、第4、5个物品合并，以此类推。
* 如果W对应位为0，下一层如果有，肯定拿2、4、6、8……个物品
    * 相当于第1、2个物品合并、第3、4个物品合并，以此类推。
* 不要忘记也有可能全部拿，最后一位有可能要补一个物品

这样做就简单多了。

## C

* 赛中看错题浪费一个小时，提醒自己看清题啊看清题

题目要求解的是一系列解，所以肯定考虑如何迭代

* 首先考虑多半是要建立Bittrie的
    * 直接的想法：每一个节点存放：这个分支下的所有字符串，覆盖这个分支的方法总数
* 然后考虑新增的解，分为几个部分：
    * 如果当前字符串直接覆盖当前节点，那么选中当前字符串，当前节点原有的字符串假设有i个，i个中任意选择 ($2^i$种)
    * 如果当前字符串不直接覆盖当前节点：
        * 当前节点终结的字符串 $i$ 个， 当前节点下属的字符串 $j$ 个，那么当前节点终结的字符串任意选择非0个，下属的字符串任意选择，　有$(2^i-1)2^j$ 个
        * 当前节点所属的分支答案增加了 $\Delta a$ 个，另一个分支的答案有 $b$ 个，则另外增加 $\Delta a·b$ 个答案。

以上，维护每个节点的终结字符串个数，总计字符串个数，就可以依次计算出每个节点覆盖组合数的变化。最后输入根节点的覆盖组合数即可。

### 赛后补充：更好的思路

覆盖的方案比较杂，如果直接想不被覆盖，那就简单的多了：

* 每个节点不被覆盖的数量，等于左分支不被覆盖的数量×右分支的总数 + 左分支总数×右分支不被覆盖的数量 - 左分支不给覆盖的数量×右分支不被覆盖的数量
* 可以不用增量直接迭代，也可以对每一部分增量计算