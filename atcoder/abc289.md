A: 简单题，直接做即可。

B: 简单题，直接枚举每个连通块，并倒序输出即可。因为每个连通块都是连续的，不需要BFS什么的，直接循环看标记即可。

C: 直接枚举并校验即可

D: 直接DP即可

E: 考虑把两个人的位置组合当做点，可以证明此虚拟图顶点数量不超过 $N*N$ ，边的数量不超过 $M*N$，因此直接BFS复杂度足够，硬做即可。

F: 构造题，首先注意到两个维度的运动相互独立，其次注意每个维度 只要用坐标差1的两个坐标跳跃两次，就能在该维度上移动2个单位的距离。并且不论如何构造，永远不会改变坐标的奇偶性，所以：

1. 如果起点和终点坐标奇偶性不同，直接判不能移动。
2. 如果起点和终点坐标值不同，且该维度上不能改变跳跃坐标（a=b或c=d），那么该维度上唯一的移动机会是进行奇数次跳跃。进行偶数次跳跃总是回到原点，而进行奇数次跳跃总是到达对称的一点。如果这样到不了终点（包括奇数次跳跃后另一个维度和终点不同，且另一个维度也无法改变跳跃坐标），那么就到不了。
3. 否则，总是可以2格2格的挪向目标点，因为起点和终点每个维度差不超过2E5，所以总跳跃次数不超过 4E5+1，符合题目要求。

G: 类似斜率DP，保存一系列“有可能超过之后的点作为最佳答案出现”的B[i]，以及记录他们超过之后点的具体C值。

按从大到小顺序排序B[i]后处理。

设每个B[i]为第一个考虑的对象时，给予不同的C，其总得分为 $(B_i+C)*i$，斜率为i。因此当此函数对于C价值的物品超过之前所有函数时，对于所有大于C的物品也会超过。因此可以想象，对可能被纳入最优解考虑范围的所有的i，其超过之前候选函数的C是单调递增的。

我们用栈保存每个潜在的考虑对象，针对每个B[i]，和栈顶比较，比较两个点时可以求交：$ (B_i+C)*i= (B_j+C)*j $ 解此方程即可求出C。如果此C小于等于栈顶的C，说明原栈顶的函数在超过之前函数之前就已经被当前函数取代，因此出栈，继续和下一个栈顶比较。

注意对交点取整可能会带来问题（明明小于或大于却误认为等于），和上一个比较时能直接比较斜率（用乘法代替除法）来避免取整。虽然这题的数据采用向上取整也过了。
