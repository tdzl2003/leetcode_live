A. 简单题，按题意实现即可。

B. 简单题，按顺序遍历，并对K个以后的o置x即可，算英文阅读理解题。

C. 简单题，答案为K和MEX{A} 中的较小者，可对A排序去重后按顺序找第一个a[i]!=i的数即为MEX{A}，可以找到K为止。

D. 数论证明题。

首先证明，当第一次遇到已标记方块时，已被标记的方块是0。证明过程略。

其次证明第一次遇到已标记方块的次数如果记做a，则a为满足 $D*a = 0 mod N$ 的最小a，那么有 $a = N / GCD(N,D)$。

接着证明有且仅有所有GCD(N,D)的倍数格被标记。

因此遍历顺序显然是从0开始，遍历a次，然后从1开始，以此类推，总计GCD(N,D)轮。

所以求出 K%a 和 K/a，答案为 K/a + (K%a)*D%N

E. 考虑每个子串中每对对称的数字的贡献，若两个数字不同，则贡献1，若两个数字相同，则无贡献。

重新整理计数顺序，则有：原数组中每对不同的数字 $0<=i<j<N$ ，贡献为其参与的回文串数量。其参与的回文串数量为 $min(i+1, N-j)$，描述为两个数距离边界的距离中的较小者。

为了实现此min，我们可以从数组正中间开始加入集合。每次加入一对数，这样新加入的数距离边界的距离总是小于等于集合中已有的数。因此求出集合中不同数的数量，并乘以 $i+1$ 即可。

求集合中不同数字的数量，可以用集合的总大小（单独计算）减去相同数字的个数。

整体复杂度 $O(N)$ 

F. 首先注意能构造成树的必要条件是$\sum{X_i} = 2N-2$（总共N-1条边，每个边贡献2个入度）

然后可以证明，设 

$$
g(X)=X中\ge2的数的个数
$$

则有树最大的直径为 $g(x)+1$。

证明：

* 首先证明能构造出这样的直径。方法为将这些度>=2的点串成一条链，并将所有多余的度用度为1的点填满，这样构造的树的直径中有 $g(x)+2$ 个顶点，直径长度为 $g(x)+1$
* 其次证明不存在长度为 $g(x)+2$ 的直径。倘若存在，则直径中包含 $g(x)+3$ 个顶点，其中至少有三个度为1的点。而一个路径中不可能存在三个度为1的点。

所以问题转换：

$$
\begin{aligned}
\sum_{x \in S}f(X) &= \sum_{x \in S}(g(x)+1) \\
&=|S| + \sum_{x \in S}g(x)
\end{aligned}
$$

其中 $|S| = mc(N, N-2) = {2N-3 \choose N-2}$ ，而另一部分则可以按每个位置的贡献拆解如下：

$$
\begin{aligned}
\sum_{x \in S}g(x) &= \sum_{i=1}^N|x \in S，X_i \ge 2| \\
&= |x \in S，X_1 \ge 2| * N \\
&= ({2N-3 \choose N-2} - {2N-4 \choose N-2}) * N \\
&= {2N-4 \choose N-3} * N
\end{aligned}
$$

所以答案为

$$
{2N-3 \choose N-2} + {2N-4 \choose N-3} * N
$$


G. 注意对于选定的连通块，断开一条边有两种情况：

1. 从原来的整颗树中断下一颗子树，并保留这个子树
2. 从当前选定的树中断开一颗子树，并移除这个子树。

设 Ai 为i层树的节点数量（可用递推 $A_i=A_{i-1}*K+1$ 求解），可设法用以下公式表达 X ：

$$
X = A_b - x_0A_0-x_1A_1-...x_{b-1}A_{b-1} \\
sum = (b==D?0:1) + \sum_i{x_i}
$$

其最佳解并不容易证明（如D=5,K=2， 31-15-7=9， 15-3-3=9，前者可能更优），但至少我们可以遍历每个可能的b，求解最小的 $\sum_i{x_i}$ 

这里可以用贪心法求解。证明：

若对某个最小的p有 $\sum_i^{p-1}{x_iA_i} > A_p$，易证 $x_{p-1} \ge K$ ，且或者 $x_{p-1}>K$ ，或者有另一个i满足 $i<p-1， x_i>0$，考虑这部分形式均可以表示为：

$x_{p-1}*K + x_i$

且使用了 K+1次操作。

显然有 

$x_{p-1}*K + x_i = x_p+x_i-1$ ，若 $i=0$，则有 $x_i=1$，可以通过K次操作完成。否则，有：

$x_p+x_i-1 = x_p+x_{i-1}*K$，同样可以通过不超过K+1次操作完成。因此，此时总是可以贪心使用 $x_p$ 操作。

因此，可以贪心尽可能的减去较大的树来完成操作。整体复杂度 $O(D^2)$ 


## Ex - Bow Meow Optimization

困难证明题

先翻译官方题解：https://atcoder.jp/contests/abc290/editorial/5769 的翻译整理。这里不附图了

设公式中，Ai,Bi的部分称作不满系数，|x-y|的部分称作不满个数。

证明以下结论：

1. 若猫和狗中有奇数，必然存在一组最优解，将其中不满系数最大的一个（或各一个）排列在整个队伍的正中间。
2. 剩下的猫和狗各分成恰好一半，排列在左半边和右半边。
3. 从正中间向两侧，不论是猫还是狗，其对应的不满系数递减。

先讨论N和M均为奇数时，分为三个步骤证明：

1. 正中间的狗和正中间的猫相邻
2. 正中间的狗和正中间的猫是各自集合中不满系数最大的一个
3. 不管是猫还是狗，越靠近中间的不满系数越大。

1证明：参考图，假设中狗在中猫左侧，其中如果有任何的动物，则猫总可以向左移，狗总可以向右移，直到中猫和中狗相邻。这个过程中所有动物的不满个数只会下降而不会上升，因此整体解一定更优。

2证明：若不是，总是可以将它们和各自集合中不满系数最大的一个交换来降低总不满值。

3证明：若有一对相邻的不满足该关系，如果同为猫或狗，总是可以交换它，不改变总不满值；若为一猫一狗，交换它们之后 更靠近中心的不满个数-2，更远离中心的不满个数+2，由于更远离的不满系数更低，总不满值会下降。

如果N和M不全为奇数时，过程类似，其中1子结论的表述和证明稍有不同，具体参考原题解的图。

随后问题可以用DP求解，DP[i][j][k] 表示 总共选择了i个动物，其中在中点左侧有j个狗，k个猫的最优解，此时每加入一个新的动物，我们可以根据i,j,k推出新加入动物的不满个数（对称的另一半总是N/2只猫N/2只狗）

