[比赛链接](https://atcoder.jp/contests/abc307/tasks)

## A

简单题，按题意求和即可。

## B

简单题，按题意暴力拼接字符串并判断即可。

如果想要优化，注意到较短的字符串的逆序 一定是 较长的字符串 的前缀，而之后多余的部分则必须是个回文串。可以借助KMP+哈希表，优化到 $O(\sum{S_i})$ 。

## C

暴力模拟题，代码稍有复杂。

注意不要看错题，是截取（所有包含黑色）的部分。

枚举A和B的相对位置，并双向检查即可：

* A、B对应位置为\#时，C对应位置也必须为\#
* C 对应位置为\#时，A和B中至少有一个为\#

## D

栈模拟题

在栈中记录每一个左括号位置，当出现右括号时，从栈中提取左括号并截取字符串即可。

> 吐槽：比C简单多了，这题目咋排的序

## E

计数题

设答案为 $F(N,M)$ ，先考虑链上所有相邻人都不同（不考虑第一个人和最后一个人），有：

$$
G(N,M) = M\times (M-1)^{N-1}
$$

意思是，第一个人随意选择，之后的每个人仅需与之前的人不同，所以有 $M-1$ 种选择。

注意到其中包含了第一个人和最后一个人相同的情况。 但注意到第一个人和最后一个人相同的情况，如果去掉最后一个人，剩下的人就完美符合要求，所以：

$$
F(N,M) = G(N,M) - F(N, M-1)
$$

据此递推可得到 $O(N)$ 的解法。如采用倍增法或等比数列求和（利用逆元），均可以在 $O(lgN)$ 时间内求解

## F

采用一个open list记录“已被感染而邻居尚未被完全感染”的所有人，可依据其“最近的未被感染的邻居”的距离构建排序树，这样就可以：

* 保证遍历每个人时，至少感染一个邻居

然后在每一天感染时，采用类似dijkstra的方法，保证找到每个人“最近”的被感染路径，这样可保证不重复处理任何一个人。

> 实际实现时，不必严格为“未被感染的邻居”，只需要考虑“未被我感染的邻居”即可。这样虽然不保证至少感染一个邻居，但保证至少经过一条新的边，总复杂度仍然不会超过 $O((E+V)lgV)$

这样，总复杂度为 $O((E+V)lgV)$ 

> TODO: 群友说的删边dijkstra还没理解，晚点仔细研究

## G

注意不要看错题，要求的不是相邻的相差不超过1，而是任意两个之间相差都不超过1。

因此可以证明，其中一些为 $\lfloor\frac{\sum A_i}{N}\rfloor$ ，另一些为  $\lceil\frac{\sum A_i}{N}\rceil$ ，并且第二类数的数目恰好为 $\sum A_i \bmod N$ 个。

因此可以将所有数都减去 $\lfloor\frac{\sum A_i}{N}\rfloor$ ，问题转化为让每个数变为0和1 。

因此可以采用DP求解： $DP[i][j][k]$ 表示前 $i$ 个数，已经有了 $j$ 个0，并且最后一个数是 k 的最小操作数。另外需要注意到最后一个数是不操作的，但可以为0和1 。

## Ex

