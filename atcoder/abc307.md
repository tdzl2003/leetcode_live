[比赛链接](https://atcoder.jp/contests/abc307/tasks)

## A

简单题，按题意求和即可。

## B

简单题，按题意暴力拼接字符串并判断即可。

如果想要优化，注意到较短的字符串的逆序 一定是 较长的字符串 的前缀，而之后多余的部分则必须是个回文串。可以借助KMP+哈希表，优化到 $O(\sum{S_i})$ 。

## C

暴力模拟题，代码稍有复杂。

注意不要看错题，是截取（所有包含黑色）的部分。

枚举A和B的相对位置，并双向检查即可：

* A、B对应位置为\#时，C对应位置也必须为\#
* C 对应位置为\#时，A和B中至少有一个为\#

## D

栈模拟题

在栈中记录每一个左括号位置，当出现右括号时，从栈中提取左括号并截取字符串即可。

> 吐槽：比C简单多了，这题目咋排的序

## E

计数题

设答案为 $F(N,M)$ ，先考虑链上所有相邻人都不同（不考虑第一个人和最后一个人），有：

$$
G(N,M) = M\times (M-1)^{N-1}
$$

意思是，第一个人随意选择，之后的每个人仅需与之前的人不同，所以有 $M-1$ 种选择。

注意到其中包含了第一个人和最后一个人相同的情况。 但注意到第一个人和最后一个人相同的情况，如果去掉最后一个人，剩下的人就完美符合要求，所以：

$$
F(N,M) = G(N,M) - F(N, M-1)
$$

据此递推可得到 $O(N)$ 的解法。如采用倍增法或等比数列求和（利用逆元），均可以在 $O(lgN)$ 时间内求解

## F

采用一个open list记录“已被感染而邻居尚未被完全感染”的所有人，可依据其“最近的未被感染的邻居”的距离构建排序树，这样就可以：

* 保证遍历每个人时，至少感染一个邻居

然后在每一天感染时，采用类似dijkstra的方法，保证找到每个人“最近”的被感染路径，这样可保证不重复处理任何一个人。

> 实际实现时，不必严格为“未被感染的邻居”，只需要考虑“未被我感染的邻居”即可。这样虽然不保证至少感染一个邻居，但保证至少经过一条新的边，总复杂度仍然不会超过 $O((E+V)lgV)$

这样，总复杂度为 $O((E+V)lgV)$ 

> TODO: 群友说的删边dijkstra还没理解，晚点仔细研究

## G

注意不要看错题，要求的不是相邻的相差不超过1，而是任意两个之间相差都不超过1。

因此可以证明，其中一些为 $\lfloor\frac{\sum A_i}{N}\rfloor$ ，另一些为  $\lceil\frac{\sum A_i}{N}\rceil$ ，并且第二类数的数目恰好为 $\sum A_i \bmod N$ 个。

因此可以将所有数都减去 $\lfloor\frac{\sum A_i}{N}\rfloor$ ，问题转化为让每个数变为0和1 。

因此可以采用DP求解： $DP[i][j][k]$ 表示前 $i$ 个数，已经有了 $j$ 个0，并且最后一个数是 k 的最小操作数。另外需要注意到最后一个数是不操作的，但可以为0和1 。

## Ex

两种不同的思路，都遇到了各自的问题，但最终都可以AC：

首先，我们将问题变形成两个长度为 $L+W-1$ 的串的错位完整匹配问题：

* S串后面增加 $W-1$ 个字符 `.` ，表示对应位置需要显示为`.`
* P串后面增加 $L-1$ 个字符 `_` ，表示对应位置可以显示任何字符。

错位匹配表示为：

* P[(i+k) mod (L+W-1)] = S[i] 或
* P[(i+k) mod (L+W-1)] = '_'

带错位匹配可以考虑变形为差平方：

$$
\sum (S_i-P_{i+k})^2 = \sum S_i^2 + \sum P_{i+k}^2 - 2\times \sum S_iP_{i+k}
$$

> 平方的目的是为了确保为非负数，这样不同的字符之间不会相互抵消。

差平方和为0 表示完整匹配上。上式中，第一部分第二部分都与 $k$ 无关可以整体求解，第三部分可以利用卷积求解。

当 $P_{i+k}$ 为通配符时，我们要让等式仍然为0。下面讨论如何解决通配符问题。

### 思路一

我们单独的考虑每个字符， $S_i, P_i$ 分别表示对应位是否为该字符 `0/1` 。这样，当 $P_i$ 为通配符时，我们可以强行做如下规定：

$$
P_{i}^2 = 0 \\
2\times P_{i} = 1
$$

不必考虑具体含义，这两个式子可以使得不论 $S_i$ 是0还是1，差平方的对应位仍然为0

> 后者的表达方式可以用逆元，也可以直接对 $2\times P_{i}$ 进行卷积。

但该思路复杂度需要进行字符集大小次的卷积，提交后TLE。

### 思路一改进

不用单独考虑每个字符，可以将字符编码后，对字符编码的每个二进制位进行判断，这样额外的复杂度变成了 $\lg$ 级别，足以通过本题。

### 思路二

修改公式，求：

$$
\sum (S_i-P_{i+k})^2P_{i+k} = \sum S_i^2P_{i+k} + \sum P_{i+k}^3 - 2\times \sum S_iP_{i+k}^2
$$

特别的，规定通配符为0，所有字符都为非0。这样，当 $P_{i+k}$ 为通配符或两项相等时，该项也为0。

分解的三项中，有一项为固定，另外两项都可以通过卷积求得。

但是最坏情况下，这个求和可以达到 $|S|^3*L$ 级别，可能会超出 $\bmod$ 从而在恰好余数为0时得到错误结果。

如果直接用ascii字符集，就会有一组样例WA。

绕过的方法包括：

* 使用多个不同的mod
* 将字符映射到更小的集合（依然会碰撞但是可能碰不到对应的测试数据）

> 注意思路一是没有碰撞问题的，因为每项最多为1，总和最多为 $L$ 