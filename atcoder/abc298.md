[比赛链接](https://atcoder.jp/contests/abc298)


## A

简单题，按题意模拟即可。

## B

简单题，分别旋转1、2、3次并判断即可。

## C

简单题，分别用一批 `multiset` / `set` 存放相关的索引，查询时依序输出即可。

## D

modint处理题

可用一个队列记录每一个数字，并用一个数记录整个数的余数。队尾进入时，余数乘10再加x。队首出队时，余数减去x乘以10的 $l-1$ 次方，其中 $l$ 时当时的队列长度。

采用一个预备数组预处理10的次方，可以在 $O(Q)$ 时间复杂度完成。

## E

DP题

首先变形问题，Takahashi要胜利需要 $N-A$ 总得分，而Aoki需要 $N-B$ 总得分。

可计算`DP[i][j][t]`表示 Takahashi还需i分， Aoki还需j分，且接下来轮到t操作（t=0表示Takahashi，t=1表示Aoki）时，Takahashi最终获胜的概率，可列出递推公式并求解。

本题直接暴力 $N^2PQ$ 就可以通过，但其实可采用前缀和或双指针优化到 $N^2$

## F

数据结构题

注意到 $Score_{r, c} = \sum_ix_{i,c} + \sum_jx_{r,j} - x_{r,c}$

所以我们可以预处理每行每列的总和（仅需包含出现了的行和列），然后按从大到小的顺序遍历所有的 `rowSum[r]+colSum[c]` ，查询对应的 $x_{r,c}$ 并减去，作为候选值。

上述的遍历过程我们可以采用多指针堆，将 `colSum` 从大到小排序，为每个 `r` 记录一个当前候选 `c` 的指针，每次即可在 $O(lgN)$ 取出候选最大值并维护对应 `r` 的指针。

另一方面，我们可以用 hash表 存储所有的 $x_{r,c}$，也可以简单的排序后用 `lower_bound` 查询。复杂度为 $O(1)$ 或 $O(lgN)$ 。

注意到一旦我们找到一组结果没有 $x_{r,c}$ ，就一定可以退出循环。因此遍历的次数不超过 $N+1$ 次。因此算法总复杂度为 $O(NlgN)$ 

> 扩展思考，如果 $x_i$ 可以为负数，怎么做？
