# 一个对 int64 进行随机一一映射的算法

某数据库主索引采用 int64 顺序生成，但不希望对用户展示，希望对用户展示一个看起来像是随机数的同为 int64 的结果。

也就是说，我们需要一个 int64 到 int64 的映射，要求确保**一一对应**

同时我们希望输出尽可能散列：如果输入的二进制有一位改变，输出平均期望有刚好一半的二进制位改变。

显然如果采用异或的思路来实现，那么就是对于输入的每个二进制位如果为 1，就将对应的一个魔法数异或到结果上。大概代码类似这样：

```C++
const int64 magiccodes[64];
const int64 magic_init = 0xdeadbeaf;

const int64 antimagiccodes[64];

int64 encrypt(int64 arg) {
  int64 ret = magic_init;
  for (int i = 0; i < 64; i++) {
      if (arg & (1LL << i)) {
          ret ^= magiccodes[i];
      }
  }
  return ret;
}

```

所以我们怎么求 magiccodes，才能确保这个映射是“一一对应”的呢（很显然如果 magiccodes 全是 0，那么就不是一一对应的）

我们可以观察出，整个运算过程等价于一个向量乘以一个矩阵，整个运算在 mod 2 下去做（相应思路我们在[开关问题](../poj/1222_1753_3279.md)里讨论的比较透彻）

那么对于模 2 的同余矩阵来说，映射一一对应 等价于 矩阵可逆 等价于 矩阵满秩。

- 如果矩阵不满秩，那么总是可以找到两个输入，它们的输出一致。（换言之，找到一组方程有两个以上的解：还记得自由基吗？通解+自由基的任意组合都是一组方程的解）
- 我们还可以找到至少一个输出，它没有对应的输入（r(M) < r([M,B])，方程无解）

所以我们要求的就是：一个随机的可逆矩阵

那么我们可以把一系列可逆矩阵 随机的 相乘。

我们可以轻易的证明，单位矩阵 再加上 任意一个位置 0 变成 1，这是一个可逆矩阵：

$$
\begin{bmatrix}
1 & 1 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

并且它的逆矩阵就是它自己。

因此，生成一系列随机的这类矩阵，将它们乘起来，就得到了一个“足够随机的可逆矩阵”。同时，把他们逆序乘起来（等价于把他们的逆矩阵逆序乘起来），就得到了“那个矩阵的逆矩阵”。

> 注意这个方法用来做加密其实是不安全的，因为使用 16 组数据就可以探测出加密矩阵，而获得到加密矩阵后，总是可以使用高斯消元法快速得到逆矩阵。
