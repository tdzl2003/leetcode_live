# 组合计数问题

## 加法原理和乘法原理

如果一个过程有 K 种不同的分类，每种分类分别有 $ A*1, ... A_k $ 种可能，那么该过程总计有 $ \sum_{i=1}^k|Ai| $ 种可能，就是所有的可能数加起来。需要注意的是，任何一个过程的可能性必须归属于一个且仅一个分类，不能有遗漏或重复。

如果一个过程有 K 个相互独立的阶段，每个阶段分别有 $ A*1, ... A_k $ 种可能，那么该过程总计有 $ \prod_{i=1}^k|Ai| $ 种可能，就是每个阶段的可能性乘起来。需要注意的是，阶段之间必须相互独立，意味着一个阶段方案的变化，不能影响其它阶段的计数。

偶尔还会有反向运用加法原理，若一个过程有且仅有两种分类，已知其中一种分类的数量为 $ a $，总的数量为 $ S $，那么另一种分类的数量为 $ S-a $ 

## 容斥原理

在使用加法原理计算时，必须没有重复和遗漏。如果存在重复，可以使用容斥原理排除。

容斥原理的简单表述是，两个集合的并集的计数，等于两个集合的数目之和，减去两个集合的交集的数目之和。

更一般性的表述：

$$
\begin {split}
& |A_1 \cup A_2 \cup A_3 \cup ... \cup A_m|  \\
& = \sum_{1 \le i \le m}|Ai| - \sum_{1 \le i \lt j \le m} |Ai \cap Aj| + \sum_{1 \le i \lt j \lt k \le m } |Ai \cap Aj \cap Ak| .... + (-1)^{m-1}|A1 \cap A2 \cap ... \cap A_m| \\
\end {split}
$$

或写作：

$$
| \bigcup_{i=1}^{n}Ai|  = \sum_{k=1}^{n}(-1)^{k-1}\sum_{1 \le i_1 \lt i_2 \lt ... \lt i_k \le n} |A_{i_1}\cap A_{i_2} \cap ... \cap A_{i_k}|
$$

不过一般情况下，为了更低的算法复杂度，我们更常采用逐个加入集合迭代的方式逐步计算所有集合的并集大小，而非使用上述的一般形式（一般形式需要 $ O(2^N) $时间复杂度）

## 分治法

很多计数问题也被叫做DP问题，正是因为它利用分治法的思路和DP一致：试图将大问题分解成更小规模的问题，从而求得递归公式。

## 映射法

如果能够构造一种运算，使一个集合里的每个元素都一一对应另一个集合里的元素，那么这两个集合的数量就是一样的。

如果能构造一种运算，使一个集合里的元素转换成另一个集合里的元素，且该运算可逆，那么这两个集合的数量就是一样的。

## 分球问题/球盒问题

分球问题是一系列经典组合问题，许多问题都可以映射到分球问题上，从而取得解决方案。
分球的8个问题是针对以下三个条件的不同回答产生的8个不同的问题：

* 球是否相同
* 盒子是否相同
* 盒子是否允许为空

> [分球的八个问题](https://zhuanlan.zhihu.com/p/462642014)

> [球盒问题：这篇笔记来就全算完了](https://zhuanlan.zhihu.com/p/429815465)

## 用于降低复杂度的数学/算法工具

常见快速求解方法有（这里不一一介绍了）

* [范德蒙德卷积](https://zhuanlan.zhihu.com/p/552934763)：用于组合式优化、化简等
* 前缀和/后缀和：常用于连续计算优化
* 矩阵，矩阵乘法：用矩阵乘法可快速求线性变换；很多幂求和问题都可以转换为线性变换问题；还利用轮换矩阵构造 $ B^k=I $ 来优化二项式间隔取数求和问题。
* 卷积（AtCoderLibrary里有[现成的](https://github.com/atcoder/ac-library/blob/master/atcoder/convolution.hpp)），建议背板/抄板，不建议死磕原理。
* 母函数：

# 例题

## [ABC 282 G - Similar Permutation](https://atcoder.jp/contests/abc282/tasks/abc282_g)

**题意**：求有多少对相似度恰好为K的N排列，结果模P输出。相似度定义为，两个排列中，相同的一组相邻下标的大小关系相同：

$$
(A_{i+1}-A_i)(B_{i+1}-B_i) > 0
$$

**思路**：和刷过的DP题：[T-Permutation ](./atcoder_dp/README.md#t---permutation)几乎一模一样，只是维度升高了一维。

按我们的表述：每往排列里插入一个元素 $ i $ ，就把之前 $ \ge i $的数字全加1。反过来说，从排列里拿掉最后一个元素 $i$ 的子状态，就把之前 $ \gt i $的数字全减1，以一一对应一个 $ 1...n-1 $的排列。

DP定义： $ DP[i][j][k][l] = (前i个元素，相似度为k，且A排列最后一个元素为k，B排列最后一个元素为l的组合总数)$

迭代时，就分为两类情况：

* 符号相同，对应两个串的符号分别为 $ <, < $ 或 $ >, > $ ；
* 符号不同，对应两个串的符号分别为 $ <, > $ 或 $ >, < $ ；

每一种符号组合分别都对应这上一层DP的区块求和，这个可以很容易通过二维前缀和预处理后 $ O(1) $ 计算来完成。

**代码** [CPP](https://atcoder.jp/contests/abc282/submissions/37446986)

## [ABC 281 G - Fasthest City](https://atcoder.jp/contests/abc281/tasks/abc281_g)

**题意**：求有多少个无向图，满足N号顶点是唯一距离1号顶点最远的点。

**思路**：N号顶点是距离1号最远的点，如果从起点开始按最短距离一层层添加点，N独属最后一层，单独处理。

每添加一层顶点时，每个顶点至少有一个连通上一层的边（满足最短距离要求），可以随意连接多个；另外，同一层的顶点中可以随意连接，也可以不连接。不能有其它类型的边被添加（会改变最短距离）。假设本层有j个点，上一层有k个点：

* 每个顶点与上一个顶点的k条边有 $2^k$ 种连接状态，但需要排除掉完全没连接的。所以总计为 $(2^k-1)^j $ 种方案
* 顶点之间总共有 $j*(j-1)/2$ 条边，每条边都可连可不连，所以总计为 $2^{j*(j-1)/2}$ 种方案

> 灵活使用加法原理和乘法原理，上一层的不同点数是不同的分类，应用加法原理；边的连接方案相互独立，应用乘法原理。

从计数角度，所以关注最后一层的顶点数和倒数第二层的顶点数，总计有多少层反而不是关键，不必在状态中包含。

* $ k \le i-j-1 $ ，除非 $ i=j+1 $，此时为第一层， $k=1$ 。

设 $ DP_{i,j} = 总计有i个顶点，最后一层有j个顶点 $ 当 $ i \ge 2 $ 时，显然有 $ 1 \le j \lt i $

$$
DP_{i,j} = \begin{cases}
\sum_{1 \le k \le i-j-1} DP_{i-j,k}*(2^k-1)^j*2^{j*(j-1)/2}  & j < i-1 \\
2^{j*(j-1)/2}  & j = i-1
\end{cases}
$$

**代码**：[cpp](https://atcoder.jp/contests/abc281/submissions/37180145) 代码为比赛中实现，其中的公式略有区别（如i不包含1号顶点）。

## [ABC 281 Ex - Alchemy](https://atcoder.jp/contests/abc281/tasks/abc281_h)

**题意** 有A种1级宝石，每种都有一大堆（题目中描述为 $10^{10^{100}} $ ），可以用n个宝石合成n等级的宝石，满足：

* 任意两个宝石都不一样
* 每个宝石都低于n级
* 2级以上的等级，每级最多只有1个宝石

如果参与合成的宝石一样，那么合成的结果就一样。

问 N级宝石最多能合成多少种？

**思路** TODO
