[比赛链接](https://leetcode.cn/contest/weekly-contest-342/)

## T1

简单题，加起来后对24取模即可。

## T2

简单题，没卡复杂度，直接枚举即可。

还可以选择归并排序方法计算。

最优的方法是采用容斥原理，得到如下公式：

$$
S = f(n,3)+f(n,5)+f(n,7)-f(n,15)-f(n,21)-f(n,35)+f(n,105) \\
f(n, i) = \frac{(i+\lfloor\frac{n}{i}\rfloor*i)*i}{2}
$$

## T3

迭代题

注意到值域非常小。可以计数（迭代维护计数）后直接在值域遍历以通过本题，复杂度 $O(N|S|)$ 其中S为值域。

如果值域较大可以使用线段树，复杂度 $O(Nlg|S| + |S|)$。如果值域进一步增大，可以进行离散化后应用线段树，复杂度 $O(NlgN)$。

## T4

证明题

首先，易证明问题有解，当且仅当数组中所有数的GCD 等于1 。

* 必要性：若数组中所有数的GCD 大于1，设其为x，那么所有数都是x的倍数，任意次操作后仍然所有数都是x的倍数，无法得到1
* 充分性：将该数组从左到右依次操作，必然能得到一个1 。然后再反方向操作，即可让所有数变为1 。

接下来讨论最小操作数：

* 若原数组中有1，最小操作数为非1元素的数量。证明：每次操作都可将一个数变为1，直到数组中所有数都变为1 。
* 若原数组中没有1，最小操作数为：得到第一个1的最少操作数，加上 $n-1$ 。证明：不论何时得到第一个1，之后每次操作可将一个元素变为1，共计 $n-1$ 个操作。同时至少需要这么多操作。

所以我们寻求尽快得到第一个1。注意到得到1的最少操作数等价于：最短的GCD为1的区段-1：

* 必要性：得到1的所有相关操作假设为K次，最多涉及K+1的连续区段。如果区段超过K+1，则不连续，其中至少有一部分对得到1无贡献。若该区段GCD不为1，也无法得到1
* 充分性：若存在长度为K+1的连续区段，其GCD为1，我们总是可以按从左到右顺序依次操作，每次改变右边的一个元素，直到最后一个元素，这样最后一个元素为区段内所有元素的GCD，即为1 

接下来我们寻求找最短区段的问题。注意GCD运算不可逆，我们首先可以依次遍历每个起点并迭代计算GCD，复杂度 $O(N^2lg|S|)$ （其中 $lg|S|$ 是辗转相除法求GCD的复杂度上界）。其次，我们还可以采用线段树来计算区段GCD，并用双指针迭代，复杂度 $O(NlgNlg|S|)$。最后，直接基于线段树进行双指针迭代，可以保证每个节点至多只进出一次，复杂度 $O(Nlg|S|)$ 。当然，因为数据范围比较小，赛中还是推荐用 $O(N^2)$ 甚至 $O(N^3)$ 方法求稳。