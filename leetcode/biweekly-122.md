## T1

注意到本题第一个区段的第一个数是固定的，后面实际上等价于 从后面 N-1 个数中找到最小的 3-1 个数，所以用不论什么方法找到这最小的2个数，加上第一个数即可。

## T2

注意到反复交换相邻的数 能够排序的前提是，任何顺序不对的（逆序的）两个数都要相互交换一次。

因此检查所有逆序的数对，其二进制位是否相等即可。

## T3

从样例里发现小的数可以直接吃掉大的数

所以只用关注最小的数有几个，以及能不能构造出一个更小的数。如果能构造出最小的数，可以只剩下这个数。

如果有数不是最小的数的倍数，那肯定能构造出一个更小的数；如果所有数都是它的倍数，那一定构造不出来（只能构造出0和最小的数的倍数）

假设最小的数的数量是 $v$ ，最后就最少剩下 $\lceil\frac{v+1}{2}\rceil$ 个数

## T4

参考T1的思路，这题采用滑动窗口的框架，就是要找每组连续的 $dist+1$ 个数中，最小的 $k-1$ 个数之和。

这题有两种解法：

* 一种是采用可删堆或排序树(multiset) 维护前 $k-1$ 个数，和它们的和，然后用另一个来维护剩下的数。这样可以（比较繁琐的）维护最小的 $k-1$ 个数的和，并支持插入和删除数。
* 另一种是将数离散化以后，采用两个线段树或树状数组，一个维护数量，一个维护总和，在树上二分找到第一个数量 $\ge k$ 的位置，其前一个位置的总和，以及根据数量推算出这个数需要加入多少个。

两种方法均可以支持 $O(\lg{n})$ 的维护和求和。