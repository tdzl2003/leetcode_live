[比赛链接](https://leetcode.cn/contest/biweekly-contest-102/)

## T1

简单题，按题意认真实现即可。

## T2

迭代题，迭代维护前i个元素的最大值和分数，可以在 $O(1)$ 时间完成迭代，总时间复杂度 $O(N)$ 

## T3

简单题。堂兄弟的和等于 同层所有数的和 减去 自己和兄弟的和。所以深度优先求出每个深度的和，再一次深度优先带上自己和兄弟的和并求解即可。

## T4

图论题。每次查询 $O(VlgE)$ 的 dijkstra算法也可以通过。还可以寻求 $O(100^3)$ 以内的方法。

注意到floyd算法可以在 $V^3$ 时间求出两两最短路径。可以构图时使用floyd计算，然后在addEdge时维护两两最短路径：

> floyd的顺序必须是中间点在最外层循环。赛中我百度到了一个坑人的错误实现。

* 假设新增的边从f到t，代价为c：
* 如果它比f到t原本的最短路径要长，直接忽略该边。
* 对每一个点i，如果f经过t到i的路径比原本f到i的路径更短，更新该距离。这样可以保证找到所有从f到i的最短路径：
    * 因为最短路径要么不经过该边（即为原图的最短路径），要么从该边开始，剩下的路径为t到i的最短路径。
* 对每一对点i,j， 如果i经过f到j的路径比原本i到j的路径更短，更新该距离。这样可以保证找到所有从i到j的最短路径：
    * 因为最短路径要么不经过f（必为原图最短路径），要么经过f（为i到f的最短路径+f到j的最短路径）

这样我们可以完成 $O(V^3)$ 的构造， $O(V^2)$ 的 addEdge， $O(1)$ 的最短路查询，从而将整体复杂度压缩到 $O(100^3)$ 
