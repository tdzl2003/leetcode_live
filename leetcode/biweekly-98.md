T1: 稍微有点麻烦的简单题，获得最小数字总是将首位变成0，获得最大数字总是将第一个非9位变成9，之后相减即可。

T2: 脑筋急转弯。注意在修改两个元素的情况下，总是能将最小得分变成0，并且不影响最大得分（因为最大得分一定来自数组中已有的其它元素）。

所以将数组排序，看从首尾累积去掉两个元素的三种方案中，哪个能让最大得分最小即可。

T3: 脑筋急转弯。注意2的整次幂无法通过其它数或得到，必须在数字中直接包含。另外如果更小的2的整次幂已经被包含的情况下，总是能或出任意的相同位数的数。所以直接遍历2的整次幂，看看数组中是否包含即可。可以用hash表，或数组保留2的整次幂后去重，均不影响复杂度。

T4：看数据范围采用二进制压缩加速是有希望暴力过掉的，我没有尝试，有兴趣可以试试。

更可靠的 $O(NlgN)$ 做法是采用懒线段树，通过懒线段树可以直接完成区段翻转（交换0的数量和1的数量）。在每个节点上保留翻转的次数

采用ATL的实现，群如下定义，其中S表示0的个数和1的个数，F表示翻转的次数奇偶性：

```
typedef pair<int, int> S;
S op(S a, S b) {
    return make_pair(a.first + b.first, a.second + b.second);
}
S e() {
    return make_pair(0, 0);
}
typedef int F;
S mapping(F f, S a) {
    if (f) {
        return make_pair(a.second, a.first);
    }
    return a;
}
F composition(F a, F b) {
    return a ^ b;
}
F id() {
    return 0;
}
```
