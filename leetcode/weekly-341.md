[比赛链接](https://leetcode.cn/contest/weekly-contest-341/)

## T1

简单题，按题意比较并返回即可

## T2

简单题，按题意比较并返回即可

## T3

贪心题

按abc的顺序迭代输出字符串，其中如果字符恰好与源字符串相同，即可贪心使用该字符。否则插入字符。

迭代输出字符串时永远abc一组迭代，迭代完成后如果源字符串也已经迭代完成，即可结束，否则继续。

可以证明该贪心方法得到的是最优解。

## T4

离线处理+DP题。

* 首先预处理所有的trip，可以计算出每个节点在所有路径中出现的次数。
    * 这里找路径的方法是首先dfs预处理出所有点的深度，然后先将起点和终点调整到相同高度，然后迭代至其祖先，直到两个点相同。注意本题是点权，所以根也有贡献。
    * 贡献逐个增加，时间复杂度为 $O(NQ)$ 。
    * 在线LCA无助于优化复杂度（因为要逐个增加贡献度），但采用重链剖分，可以优化到 $O(QlgN)$ 时间。
* 然后可采取一次DFS时DP，计算出每个点为0 或 为1时整个子树的代价，可在均摊 $\Theta(1)$ 时间完成转移，总时间复杂度 $\Theta(N)$ 

所以整体时间复杂度为 $O(NQ)$ 或 $O(N + QlgN)$