[比赛链接](https://leetcode.cn/contest/weekly-contest-352)

## T1

简单题，暴力即可通过。但是显然可以构造 $O(N)$ 的迭代算法：

* 记录上一个数last和已有数量cnt，初始默认为0
* 遍历处理每一个数：
    * 如果比threshold大，重置last和cnt并从下一个数开始重新计数
    * 如果cnt>0，并且当前数和上一个数奇偶性相同，清空last和cnt，但仍然继续
    * 如果cnt=0，并且当前数是奇数，重置last和cnt中断并从下一个数开始重新计数（必须从偶数开始）
    * 记录last；cnt++;保存最大的候选答案。

## T2

质数表模板题，打表后遍历小于等于 $\lfloor\frac{n}{2}\rfloor$ 的所有素数 $p$ ，并检查 $n-p$ 是否也为素数即可。

## T3

首先基础框架为双指针：考虑每个下标作为结尾，其最长不间断的最早开头至该下标范围内的每一个子数组都是不间断的。

然后考虑如何迭代起始指针。有两种思考框架：

### 思路一

考虑到不间断子数组中的取值范围最多只有三个，因此可以记录当前的最大值、最小值、以及每个数的数量。然后进行如下迭代：

* 如果新的数比最大值大3以上，或比最小值小3以上，可以直接重置计数，从当前数重新开始。
* 如果新的数比最小值大3以上，或比最大值小3以上，可以持续进行迭代前指针，减少每一个计数，直到最大值/最小值的数量清空。因为之前最大值最小值的差不超过3，所以直接对值进行查找即可找到新的最大值最小值。迭代直到加入新的数以后，最大值和最小值差仍不超过3。
* 随后加入新的数，并维护最大值最小值。

该方法可以在 $O(N)$ 时间内解决。

### 思路二

考虑我们要求的是双指针区段内的最大值和最小值之差，可以采用两个单调队列来分别计算最大值和最小值。

例如计算最大值的单调队列：

入队时：
* 如果新的数比队列尾部的数大，从队列尾部出队。
* 将新的数加入队列。

出队时：
* 如果出队的数和队列头部的数相同，从队列头部出队。

这样在单调队列中，维护的是一个递减的序列，其中包含了每一个“候选最大值”。而队列的头部即为当前区段的最大值。

这样同样可以在 $O(N)$ 时间内解决。

> ST表或线段树也可以在 $O(NlgN)$ 时间解决本题，足以通过。

## T4

数据结构&迭代题

暴力算法是 $O(N^3\lg N)$ 的，不足以通过本题，进行相应优化。

> 据说优化的 $O(N^3)$ 在某些语言下有可能通过。

## 思路一

采用迭代维护相邻值：

* 用一个multiset维护所有的值
* 每当一个新的值被插入时，检查其旁边的两个值：
    * 是否中断了一个不平衡数字
    * 是否引入了一个或两个新的不平衡数字

这样可以在 $O(lgN)$ 时间维护插入一个新的值，算法总复杂度 $O(N^2lgN)$ 足以通过本题。

## 思路二

考虑不平衡数字即为：没有出现下一个数字，可以进一步改进，采用哈希表计数，并使用如下方法迭代：

* 若插入的数已经存在，不计额外的数。
* 若插入的数-1已经存在，减少一个不平衡数字。
* 若插入的数+1不存在，增加一个不平衡数字。

注意首个数字插入时也会增加不平衡数字，所以不平衡数字初始化为-1 。

这样可以在 $O(1)$ 的时间完成迭代，总复杂度 $O(N^2)$ 。

## 思路三

在思路二基础上进一步思考，每个数 $v$ 产生贡献的子数组，是 $v+1$ 没有出现的范围。另外相同的数字出现时，我们假设只有第一个数字有贡献，因此：

* 找到每个数 $v$ ，之前最近一个 $v+1$ 出现的下标 $p_i$
* 找到每个数 $v$ ，之后最近一个 $v$ 或 $v+1$ 出现的下标 $s_i$

可以采用哈希表在 $O(N)$ 时间内分别完成前后缀的迭代处理，然后即可计算出每个数产生贡献的子数组数量为： $(i-p_i)\times (s_i-i)$

注意每个子数组的最大的数其实是不应该产生贡献的，但上述过程多余计算了，因此要剔除。显然每个子数组最大的数只有一个，所以总数上剔除 $\frac{N(N+1)}{2}$ 个。

整体复杂度 $O(N)$ 