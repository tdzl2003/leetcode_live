## T1

简单题，按题意循环并累加即可。

## T2

题目变形：找到一些下标，其中最大值和最小值的差不超过 $2k$ 

显然将数组排序也不改变结果的数量。

因此将原数组排序，可采用双指针求解。总复杂度 $O(NlgN)$

## T3

很显然，在两部分数组中过半的数，必然是原本数组中过半的那个数。

因此，对原数组（采用对消法）找到过半的那个数，统计它的数量，之后在遍历时迭代维护已经经过的该数数量，即可根据下标计算出两个部分是否符合条件。

三次遍历均为 $O(N)$ ，算法复杂度为 $O(N)$ 

## T4

框架性思路上，采用双指针，当当前串包含了任何一个forbidden串时，移动前指针，直到符合条件为止。

因为forbidden长度较短，采用hash表查询可以在 $O(KM + NM^2)$ 时间内求解，其中 $N$ 是word的最大长度， $M$ 是forbidden最大的长度， $K$ 是单词的个数。

采用AC自动机，可以在 $O(KM|C| + N)$ 时间内完成， $|C|$ 是字符集大小。 其中 $KM|C|$ 是构造自动机的空间&时间复杂度。遍历时：

* 若当前无匹配，直接移动右指针并迭代AC自动机
* 若当前有匹配，直接移动左指针到匹配串开头的下一个字符，此时相当于强行当做匹配失败，进行一次fail操作。

这样可以在 $O(N)$ 时间内完成双指针迭代。