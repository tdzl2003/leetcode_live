[比赛链接](https://leetcode.cn/contest/weekly-contest-346/)

## T1

简单题

本题并没有什么边界，直接贪心就能得到正确答案，直接贪心模拟可以在 $O(n^2)$ 时间通过本题。

考虑使用一个stack来模拟，如果栈顶是AB或CD即出栈，这样可以在 $O(n)$ 时间完成。

## T2

简单题

如果长度为奇数，中间的那个字母总是不用操作；除此外，每对对称位置的字母如果不相等，就需要操作一次。

既然要求字典序最低，那么操作时总是选择更小的那个字母即可。

## T3

DP题

对每个数进行DP验证，看看能否组成自己即可。

直接这样做会超时，但是注意到 仅当 $i^2 \equiv i \mod 9$ 时可能有解，因此加上这个验证即可通过。

## T4

压轴题，LC难得出一道有难度的题，点赞

首先的思路是 直接求一遍最短路径（用dijkstra），不考虑-1的边（或把-1的边当无穷大处理），如果得到的最短路径仍然比目标小，那么显然无解。

然后考虑把所有-1的边 都设到最小（1），再求一遍最短路径。如果得到的最短路径仍然比目标大，那么同样无解。

接下来我们设法构造一个目标长度的最短路径。首先，因为我们已经找到了一条比目标短的最短路径，我们只需要考虑修改这条路径上的权值，所以我们可以先把所有不在这条路径上的 -1权值的边 设为无穷大（或 $2*10^9$ )

因此我们循环做如下处理：

1. 如果当前求得的最短路径等于目标，就将所有剩余边的权值标记为1，并返回。
2. 否则，将当前最短路径中第一条不确定权值的边的权值设置为 $target-path+1$ 。容易证明这样最短路径仍然不会超过 target
3. 之后重新求一遍最短路径。注意此时存在可能性，新的最短路径绕过了刚刚设置的边，因此我们需要回到第一步继续循环。

以上算法每次至少确定一条边的权值，因此最多进行不超过 $n-1$ 次（ $n-1$ 是最短路径长度的上界 ），每次求最短路径复杂度 $O(n^2lgn)$ ，所以总复杂度 $O(n^3lgn)$

是否存在可能 最后一条边的权值仍然被绕过，导致上述算法得到一个错误解呢？我们可以证明不可能，因为每当一条边被绕过时，新的最短路径仅包含原图中已有权值的边 和 新的未确定权值的边。 如果所有的未确定权值的边都被绕过，那么得到的最短路径 等同于我们最开始查找的（把所有未确定权值的边都当做无穷大） 所找到的最短路径，而最开始我们已经确定该路径长度不小于 $target$ 。