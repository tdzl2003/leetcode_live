[比赛链接](https://leetcode.cn/contest/weekly-contest-338/)

## T1

简单题，贪心尽量选择1，然后尽量选择0即可。

## T2

贪心，每次在满足条件的前提下，让当前的数尽量小即可。

## T3

迭代求和题，可以选择双指针或线段树来完成

对于查询 $q_i$ ，nums中比它小的集合为 $M$ ，大于等于它的集合为 $N$ ，代价为：

$$
cost = |M|*q - \sum_{x\in M}x + \sum_{x\in N}x - |N|*q
$$

所以可以将 $nums$ 排序后求出前缀和，二分查找对应的bound。总复杂度为 $O(QlgM)$ 

还可以采用离散化线段树查询比 $q_i$ 小的集合数量 及其总和，从而推算出另一个集合的数量和总和。（比较麻烦）

也可以将 $nums$ 和 $q$ 分别排序（建议 $q$ 排序下标，因为返回值需要保持顺序），这样随着 $q_i$ 增加，总是从集合 $N$ 中取出若干元素放入 $M$ ，取的数量不超过 $|nums|$ ，考虑排序，总复杂度为 $O(MlgM+QlgQ)$

## T4

我采用换根DP方法来解决此题，状态模板中记录：

* 最深的一个coin的深度
* 必须要抵达的点的个数

最后需要经过的边的数量，就是必须要(抵达的点的个数-1)*2 。另外注意根是必须经过的。

另外，可以采用“侵蚀”的思路，先拿掉所有为0的叶子节点，然后进行两次：拿掉所有的叶子，剩下的点的数量就是必须经过的点的数量。

事实上，因为要经过的点集是确定的，拿掉所有为0的叶子节点后，从任意必须经过的点出发dfs，也可以得到最优解。一种找到必须经过的点的方法是在子图的直径上找中点。
