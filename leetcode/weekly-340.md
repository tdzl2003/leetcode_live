[比赛链接](https://leetcode.cn/contest/weekly-contest-340/)

## T1

简单题，按题意求即可。用素数表模板打表200( $\sqrt{max}$ )以内素数，然后检查对应的数是否存在表中的质因数即可完成判定。

## T2

迭代求和题

注意到具体的值不影响答案，影响答案的仅有值之间的相等关系，因此可以先进行 $O(N)$ hash表离散化，或先进行 $O(N\lg{N})$ 排序离散化。

注意到对每一个 $i$ ，其返回值为：

$$
\begin{aligned}
& \sum_{j\in\{j|a_j=a_i\}}|i-j| \\
=& \sum_{j\in\{j|a_j=a_i, j<i\}}(i-j) + \sum_{j\in\{j|a_j=a_i, j>i\}}(j-i)
\end{aligned}
$$

令两个集合分别为 $S_{pre}, S_{post}$ ，有：

$$
\begin{aligned}
& \sum_{j\in S_{pre}}(i-j) + \sum_{j\in S_{post}}(j-i) \\
= & i*|S_{pre}| - \sum_{j\in S_{pre}}j + \sum_{j\in S_{post}}j - i*|S_{post}|
\end{aligned}
$$

因此可以对每一个值，迭代维护两个集合的数量和总和并进行计算。因为值的数量不超过 $N$ ，所以总计在 $O(N)$ 的时间完成这个步骤。

## T3

典型的难以直接求解的问题，但可以在线性时间内完成验证，因此考虑采用二分查找。

套用“二分查找寻找最小的满足`test(t)`为true的t” 的模板，`test(t)` 表示是否可以找到 $p$ 个下标对，满足差值不超过 $t$ 。显然该判定函数单调。

判定函数可采用贪心方法求解：

* 按从小到大顺序遍历数组（需要在二分查找开始前对原数组排序）
* 如果某数和下一个数之间的差不超过 $t$ ，将其配对，计数器加一。
* 最后判定计数器数量是否 $\ge p$ 

证明过程如下：

* 可证明，若判定存在解，一定存在一组解，满足：
    * 在排序后数组中，任意选定两对数不交叉，否则可以交换相近的一对数，仍然满足条件。
    * 任意选定的一对数都是相邻的；否则我们因为没有交叉，总是可以替换其中一个为更接近的数。
    * 选择的每一组数都尽量小。若上一个数距离小于 $t$ 而未被选择，我们总是可以替换下一个数为上一个数，得到相同的一组解。
* 因此如果存在解，该贪心策略总能找到一组解。

## T4

首先问题为无权值最短路问题，因此考虑采用BFS。这题的难点在于每个点可达的是一个范围，如果不做优化，复杂度为 $O(NM(N+M))$ 。

考虑BFS遍历每个点的相临边时，我们仅需找到未抵达过的点，因此我们寻求办法让我们仅需遍历未抵达过的点。这里可以采用多种办法：（下面这段的N均为序列数量，并非原题中的N）

* 采用排序树（如set）维护所有未抵达的点，每次抵达后从set中删除。查询和维护复杂度 $O(lgN)$ ，常系数较大，但这是最简单的实现。
* 采用线段树或树状数组维护，将未抵达的点视作1，已抵达的点视作0，可采用树上二分查找在 $O(lgN)$ 时间维护。
* 采用[线性序列并查集](https://www.cnblogs.com/bzy-blog/p/linear-sequence-disjoint-set.html) 维护每个连续的区段，并规定root为序列开头，复杂度低于 $O(lgN)$ 高于 $O(lglgN)$ 
* 以上所有方法均可采用bitset预压缩，对bitset的非0段视作1，0段视作0，从而将复杂度压缩为 $O(\frac{lgN}{W})$ 其中 $W$ 为CPU字宽。

采用上述任意一种方法优化BFS，均可以达到复杂度 $O(NM(lgN+lgM))$ 以内，最低可达到 $O(NM)$ （当 $lgN \lt W$ ）