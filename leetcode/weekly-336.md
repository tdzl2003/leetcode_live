[比赛链接](https://leetcode.cn/contest/weekly-contest-336/)

## T1 

简单题，按题意处理即可。

## T2

贪心；可以证明存在一组最优解按照如下方式构造：

* 将所有的数按从大到小顺序排序。

因为在上述基础上，任意调整顺序都只会导致某些前缀和变小而没有前缀和会变大。

所以按从大到小将数组排序后遍历尝试即可。排序复杂度为 $O(NlgN)$

## T3

首先，可以证明美丽子数组 就是每个二进制位上1的个数都是偶数个。这等价于异或为0 。

然后寻找数组中所有异或为0的区段，可以存储所有前缀的异或和，区段的异或和即为两个前缀异或和的异或。因此一组前缀异或和相同即为一组美丽子数组。 

采用连续迭代计算和哈希表存储，时间复杂度为 $O(N)$ 

## T4

首先考虑基础贪心策略，因为电脑同时可以运行无数个任务，所以等着deadline快到了不得不开工再开工，而一旦开工就尽可能处理所有处在时间范围内的任务，即为最佳策略。

因为假设存在一个不符合这个约束的最佳策略，我们总是可以将所有相关任务向后拖延1单位时间从而得到一个不会更坏的策略，直到所有的任务都押着deadline执行为止。

本题在上述策略下， $O(N*|T|)$ 时间硬模拟即可得到答案。我们来看看能否得到更低复杂度的方案。

首先，寻找deadline最早的任务，我们可以考虑用排序或堆来完成。考虑到开工后其它任务的剩余deadline可能会被推迟，可能更适合用堆来完成。

为了避免每次维护所有的任务，我们记录计算机已工作的时间总和，并假设堆中记录的是 `deadline-已工作时间总和`。而start到达时，我们将已工作时间总和加到该任务的duration上，等价为没有start限制 而该任务已经参与了所有工作。这样，开展工作时，堆中所有的记录都无需被修改。

所以算法流程如下：

* 初始化总工作时间，开始为0
* 遍历每一个任务：
    * 首先处理到期时间在本任务开始之前的任务
        * 如果该任务结束时间也在本任务开始之前，则完整执行该任务，并继续内层循环
        * 如果该任务结束时间在本任务开始时间之后，则部分执行该任务直到本任务开始时间为止，并退出循环。
    * 然后将本任务插入队列，假设本任务已经执行了总工作时间，剩余duration时间需要执行。
* 最后继续处理所有队列中的任务直到处理完成。

[高难版题目链接](https://leetcode.cn/problems/t3fKg1/)