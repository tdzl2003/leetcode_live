A. 简单题，按题意模拟即可

B. 简单题，迭代计算求出work[0,,,i] mod m 即可

C. 首先互不相同，可以将数组排序。

若 i 到 j 可以匹配，那么对所有的 $0\le u \le i$ 和 所有的 $j\le v \lt n$ 都可以匹配。

所以若至少有x组可以匹配，那么总是可以将 $0 \le u \lt x$  和 $n-x \le v \lt n$ 依次进行匹配。

所以可以在 $O(x)$ 时间完成验证，二分目标x找最大的匹配数量即可，总复杂度 $O(nlgn)$ 。

更进一步的，可以证明 $x < n/2$，因此可以将数组分成两半，如果有解，一定存在一组解的每个i落在左半边，而每个j都落在右半边。此时按顺序为每个i贪心找最小的可以匹配的j，可以证明必然能找到最大的匹配方法数，总复杂度$O(n)$。

D. 考虑在BFS基础上，约束每个点抵达的最早时间。虽然最早时间限制不同于边权，但是当上一点的最早抵达时间确定的情况下，边权可以确定为 $max(1, 最早时间限制-上一点最早抵达时间)$，这个过程可用dijkstra解决，使用堆优化，时间复杂度 $O(n*m*lg(n*m))$。

套A*模板可在相同复杂度下略微优化搜索性能。