## T1

简单题，按题意枚举所有比 $n$ 小的二进制位，与 $n$ 做或处理即可。

另一种方法，是当 `n&(n+1) != 0` 时，也就是n不全为1时，使 `n=n|(n+1)`，也就是置最低一个非0位，这样循环次数会少一点，但除了炫技以外并无实际作用，并不建议在赛中做这样的尝试。

## T2

朴素的枚举法复杂度 $O(N^2)$ 会超时，因此需要更加巧妙一点。

易发现除了异常值以外的所有数的和，恰等于表示和那个数字的两倍。

因此枚举特殊数字，判断剩下数字的和是否为偶数，并且其一半是否出现即可。

因为值可能重复，这一点上需要小心处理。

> 本人vp时踩坑：rest % 2 != 0 和 rest %2 == 1 是不一样的。请大家猜猜区别在哪里？

## T3

因每次查询独立，可知一定是把点 $i$ 和另一棵树的中心相连，因此问题变为先求： 

对一棵树中的每个点，求距离k以内有多少个点（包括自己）

之后第一棵树中的每个点的答数，加上第二棵树对于 $k-1$ 求出的最大值 即可。

对于本题范围直接暴力dfs即可求出，点分治可以在 $O(NlgN)$ 的时间内求出。

> [点分治的板子更新了](https://github.com/tdzl2003/algorithm_workspace/blob/main/cpp/tdzl/graph/tree.hpp)

> 群友给的[点分治拓展题](https://judge.yosupo.jp/problem/vertex_add_range_contour_sum_on_tree) 也 [过掉了](https://judge.yosupo.jp/submission/253831)

## T4

和T3类似，但题目内容更简单，不需要点分治，dfs的时候维护出深度为奇数的点和深度为偶数的点即可。

本题的数据范围还没有考察一个边界情况：一般来说总是可以贪心选择第二棵树中较多的个数，除非两个树恰好都各自只有一个点，此时到该点的距离一定为1
