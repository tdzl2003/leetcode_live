[比赛链接](https://leetcode.cn/contest/season/2023-spring/)

# 个人赛

## T1

简单题，没有卡复杂度，按题意 $O(N^2)$ 模拟即可。

注意这题如果要用堆，得用可删堆，处理起来相对麻烦。比赛中不建议尝试。

## T2

简单题，按题意分割字符串并用哈希表统计即可。

C++没有支持std20，这题比较吃亏。改用js、python过比较容易。

## T3

扫描线遍历题。

题目范围比较小，采用两次扫描线遍历即可。外层在水平方向扫描，每扫描到一个边缘，对所有处在激活态的矩形进行垂直方向的扫描，即可找到最大值。

扫描线可采用event遍历机制，为每个矩形插入一个进入一个退出两个event，将event进行排序，然后顺序遍历。

注意重叠的边缘是记录在内的，因此扫描时要先扫描起点再扫描终点。

## T4

寻路题。

首先从终点开始BFS，可计算出从每个位置距离水晶的距离，或不可达为-1。

接着可根据上述信息，求出 如果在每个位置被传送，传送后的最大距离，或不可达为-1，记为当前格子的代价。

然后从起点开始寻路，若某点别传送后不可达，则对小扣来说不能到达该点。否则，当前格子代价最大的即为整条路径的代价。

因此第二次寻路，可采用堆，尽量去尝试代价较小的格子，直到抵达终点或无路可走为止。

## T5

复杂DP计数题。

要比较顺利的解决这题，首先要想到一种办法来描述当前的状态。

我们考虑用状态机来记录最近的两个棋子颜色：

```mermaid
graph TD
0([.]) --"."--> 0([.])
0([.]) --"B"--> 1([B])
0([.]) --"R"--> 2([R])
1([B]) --"."--> 1([B])
1([B]) --"B"--> 3([BB])
1([B]) --"R"--> 4([BR])
2([R]) --"."--> 2([R])
2([R]) --"B"--> 5([RB])
2([R]) --"R"--> 6([RR])
3([BB]) --"." --> 3([BB])
3([BB]) --"R" --> -1([Fail])
3([BB]) --"B" --> 3([BB])
4([BR]) --"." --> 4([BR])
4([BR]) --"B" --> 5([RB])
4([BR]) --"R" --> -1([Fail])
5([RB]) --"."-->5([RB])
5([RB]) --"B"--> -1([Fail])
5([RB]) --"R"-->4([BR])
6([RR]) --"."-->6([RR])
6([RR]) --"B"-->-1([Fail])
6([RR]) --"R"-->6([RR])
```

每列可能有7个状态。可以将该状态机数据化，同时用于行上的合法性判断和列上的状态转移。

```cpp
vector<vector<int>> d = {
    {0, 1, 2},
    {1, 3, 4},
    {2, 5, 6},
    {3, 3, -1},
    {4, 5, -1},
    {5, -1, 4},
    {6, -1, 6},
};
```


题目限制了 $n\times m\le 30$ ，当 $n\lt m$ 时，可以将棋盘沿对角线反转以加速运算，此时 $m\le 5$ ，最多有 $7^5=16807$ 个状态。

总复杂度 $7^5\times 3^5\times 6$ 考虑实际还有大量的状态在前几层不会发生，且行上的有效状态也小于 $3^5$ ，该复杂度足以通过此题。

还可以使用轮廓线DP，增加一个维度作为当前行的状态，从而在 $7^5\times 7\times 3\times 5\times 6$ 复杂度内解决本题。

# 组队赛

## T1

简单题，排序后贪心迭代，并记录遍历到的最大值即可。

## T2

很容易找到 $O(N)$ 时间验证一个值是否合法的贪心方法，因此采用二分查找即可找到最大值。

贪心的方法：所有的城墙都尽量向左膨胀，直到没有空间为止。

## T3

因为提取字母的次数是固定的，所以计算代价时，可以只计算移动的代价，最后再加上提取字母的代价。

大框架上采用DP，求到每个字母时，处在棋盘上每个坐标时的最小代价

思路A：（我的赛中思路，实际赛中没用）

考虑寻找上一个字母加上到当前坐标的距离的最优解，因为距离 $=|x'-x|+|y'-y|$，分四个方向考虑。

以 $x\le x', y\le y'$ 方向举例：

$DP' = DP + |x'-x|+|y'-y| = DP-x-y+(x'+y') $

其中 $x'+y'$ 对当前字母来说是固定的，因此我们仅需枚举该范围内的最小的 $DP-x-y$ 即可。该枚举可以使用预处理得到，预处理复杂度为棋盘大小。最后可以得到 $O(HW|S|)$ 的复杂度。

思路B：（队友的赛中思路）

把上一轮的所有相同字母当做起点，走一轮dijkstra，或bfs的过程中不断加入相同距离的顶点，可以一次遍历求得到所有下一个字母的最小代价。

如果用dijkstra，复杂度 $O(HW|S|lg(HW))$ ，也足以通过；如果用bfs，复杂度也为 $O(HW|S|)$

思路C：（赛后想到的思路）

对抽象的图进行bfs，顶点/状态为 `(x,y,字母序号)` ，最后找到任何一个字母序号为 $|S|$ 的状态即结束。

这个bfs实现比前两种方法都更简单，复杂度同样为 $O(HW|S|)$

## T4

首先，每个子树的字符串长度是固定的。因此整体方案字典序最小，就要求每个子树的方案字典序最小。最后我们从方案中移除掉尾随的所有1即可。

可以证明，因为每个子树的方案特性（整个串的0和1数量相同，但任何前缀的0都多余1），所以不存在某个子树的方案是其它子树的前缀，因此拼接后的字典序最小等价于将字典序更小的子树放在前面。

因此在求得每个子树的方案后，将所有子树排序并拼接即可。

本题直接暴力字符串排序 $O(n^2)$ 也能通过。如果规避字符串拼接，采用链表遍历，可以证明时间复杂度为 $O(nlgn)$ 。

## T5

首先，所有操作都不存在进位或借位，所以很显然可以逐位处理。

考虑 NAND 操作的规律：

```
0 NAND 0 = 1
0 NAND 1 = 1
1 NAND 0 = 1
1 NAND 1 = 0
```

因此可以观察出，当遇到一个0时，NAND的结果总是会变成1，而遇到1时，当前值总是在0和1之间变化。

所以每一位的结果可以这样快速求出：

* 如果被运算的所有位的都是1，那么看 $x*n$ 的奇偶性，为奇数则该位变化，否则该位不变。
* 如果被运算的所有位中有0，只看最后一个0之后1的个数，为奇数则该位为0，否则该位为1。

所以采用`set` 或其它数据结构，记录所有0的位置，并能在 $O(lgn)$ 时间快速求出最后一个0的位置即可。

## T6

首先，直接暴力超时。想到二进制状态计算每个子集，子集遍历部分很快但是模的可能性太多了，几乎起不到什么优化效果，和暴力相当。因此需要meet in middle 方法。

[出题人蛙佬这题的题解](https://leetcode.cn/problems/cnHoX6/solution/gong-mo-ti-jie-by-hqztrue-q5a0/) 更专业，且有详细的复杂度分析，推荐阅读。

### 思路1

队友想到的思路，较容易实现，但是还是很容易TLE。对应蛙佬的算法三。

枚举树的每一种组合，预先构造好遍历的路径，留下几个空用来填写宝石（类似欧拉序列）。

然后，我们选出 $\lfloor\frac{n}{2}\rfloor$ 个宝石，用来放在靠前的几个空，剩下的放在靠后的几个空。选择完成后，前后两个部分各自的长度也是可以确定的。

然后，我们将前几个空的所有排列和后几个空的所有排列分开处理，枚举出各自所有模值的组合数量。我们可以根据前面排列的模值，计算出后面排列所需的模值，从而直接求得对应的组合数量。

时间复杂度 $O(C_{n-1}{n\choose n/2}(\frac{n}{2})!)$ ，有些紧张，很容易TLE 。

### 思路2

我赛中用的思路，对应蛙佬的算法二。

还是在二进制状态计算的基础上改进，考虑 $\lfloor\frac{n}{2}\rfloor$ 个以内的组合数较少，我们仅预处理并压缩数量小于这个数量的子树。

然后，我们从根开始，直接枚举较小的子树的所有可能性，据此可以计算出另一个子树所需的模值（过程中用到10的逆元），然后递归调用自身求解这个较大的子树。当子树大小到达  $\lfloor\frac{n}{2}\rfloor$ 以内的时候，就可以直接查表求出结果。

这种算法的时间复杂度 有点难以计算，但拍脑袋 应该小于 $C_{4}*\frac{9!}{4!}$ ，足以通过此题。根据蛙佬的分析，比思路1还更稳妥一些。

> 注意边界情况，$p=2或5$ 时，因为最后一位总是9，所以或者所有的排列都是正解（ $target=1或4$），或者无解。这也是会导致10不存在逆元的情况，必须特殊处理。

> 感谢蛙佬没有让p任意，否则我赛中应该做不完此题了。