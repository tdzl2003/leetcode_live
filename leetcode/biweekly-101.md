[比赛链接](https://leetcode.cn/contest/biweekly-contest-101/)

## T1

简单题。

若两个数组里有重复的数字出现，选择重复的数字中最小的。否则，从两个数组中各选一个最小的数字，将其中的较小者放在十位，较大者放在各位即可。

## T2

迭代题/DP

可以使用前缀和（记录最小前缀和，当前前缀和减最小前缀和即为候选解）迭代求解，也可使用DP求最大区段和。

## T3

证明+迭代。

首先很容易证明，在循环数组里相距为 $k$ 的两个元素相同：考虑相邻的两个长度为 $k$ 的数组，其中仅有一个元素不同，且相距为 $k$ 。要使他们和相同，不同的这两个元素必须相同。

接着因为原数组是循环数组，可以证明原数组所有相距为 $gcd(k, n)$ 的元素相同：根据扩展欧几里得，必然存在一个 $i$ 满足 $i\cdot k = gcd(k, n) \bmod n$ 。

在满足上述条件的情况下，我们可以证明每一个长度为 $k$ 的连续子数组和均相等。

因此解法如下：

* 首先使用辗转相除法求 $g = gcd(k, n)$ 
* 然后将原数组依据下标模 $g$ 余数分组，求每一组使所有数相等的最少操作数。

在求每组数中的最少操作数时，可以使用迭代法，枚举每一个数作为目标，迭代维护之前和之后所有数的和，可以根据这些数的和和数量在 $O(1)$ 时间求出最少的操作次数。

总算法时间复杂度为 $O(N)$

## T4

从每个点出发BFS一遍，若最小环包含该根节点，必然会在某处得到一个相同或相邻深度的额外边（边的两个端点都已经到达）。为了保证找到最小，至少要完成该层遍历；稳妥起见我们完成整个bfs并记录最小值。

部分选手试图用每个点出发的dfs来解决此问题，实际上DFS不能保证优先遇到最小的环。虽然从每个顶点出发可以通过比赛中的数据，但下述数据通过两条长链仍然可以卡住dfs的解法：

```
13
[[0,1],[1,2],[2,3],[3,4],[4,5],[0,8],[0,9],[9,10],[10,11],[11,12],[12,7],[0,7],[0,6],[5,7],[5,6]]
```