## T1

简单题，按题意模拟即可在 $O(N^2)$ 时间内解决。

若要在 $O(N)$ 时间内解决，可以反向思考：

* 准备开头和结尾两个buff
* 按倒序处理原始字符串，默认往结尾buff里写入
* 每遇到一个i，切换到另一个buff写入
* 最后 开头 + 结尾.reverse() 即为所求。

## T2

纯暴力DP $O(N^2)$ 的状态， $O(N)$ 的转移 和 $O(N)$ 的区间求和，总计 $O(N^4)$。

采用前缀和优化前缀求和可以优化到 $O(N^3)$ 

进一步证明：因为所有的数都是正数，任何区间的和都比父区间小，所以若存在一种分割方案 分成a和b两个子数组，必然也存在一种方案每步都是这样操作：

* 每次仅从头部或尾部取下一个数字。

因为若a和b两个子数组均有2个以上数字，总是可以从头部不断去掉单个元素直至剩下b子数组。

这样转移可以修改为 $O(1)$ 的，整体复杂度 $O(N^2)$

还可以进一步证明，有解当且仅当：

* 数组的总长度为1或2
* 或者，存在一个长度为2的子数组，其和大于m

充分性：

* 因为存在这样一个子数组，我们可以最后分割该子数组，之前每次都从子数组之外去掉一个元素，所有的操作都符合要求。

必要性：

* 如果不存在这样的子数组，我们可以证明：
* 任何长度为3的子数组都无法进一步分割得到合法解
* 任何长度为4的子数组都无法进一步分割得到合法解
* 以此类推

所以我们仅需判断上述条件是否成立即可，整体复杂度 $O(N)$ 。

## T3

首先，我们可以采用一次BFS，求出每个点距离最近的小偷的距离。

然后我们有至少三种方法解决这道题：

* 二分目标安全系数，仅允许通过安全系数以上的单元格，然后使用BFS检查起点和终点是否连通。复杂度 $O(HWlg(H+W))$ 
* 从起点开始dijkstra，权值求和方式为 $min$ ，相当于按安全系数从高到低寻找连通性。复杂度 $O(HWlg(HW))$ 
* 按安全系数从高到低启用每个各自，采用并查集判定起点到终点的连通性。并查集复杂度看做 $O(1)$ 的话总复杂度 $O(HW)$

## T4

只考虑第一部分得分，我们可以将数组排序并取最大的 $K$ 个。

但更多的分类数可以带来更高的第二部分得分，所以我们继续向后查看，如果找到一个新分类，我们尝试将原来最小的*多余数字*（指超过2个元素的分组中，不是最大的那个数字）移除，加入新的分类。

可以证明，如果最佳答案只包含 $i$ 个分组，上述过程一定经过了最佳答案：

* 如果 $i\lt j$ ，其中 $j$ 是最大 $K$ 个元素的分组数，那显然前 $k$ 个是一个更佳的答案，矛盾。
* 如果 $i=j$ ，显然最佳答案是最大的 $K$ 个元素。
* 如果 $i\gt j$ ，上述过程中分组数到达 $i$ 的时候，选择了最大元素最大的 $i$ 个分组，并且选择了全局最大的额外 $K-i$ 个元素，所以也能证明是最大的。