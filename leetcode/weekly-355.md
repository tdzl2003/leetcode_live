## T1

简单题，在许多语言下可以一行解决：先join再split。

## T2

贪心题。

每次是删掉前面的数然后向后加，我们可以反过来理解，后面的数吃掉前面的数。

我们可以证明，最优解必然：

* 只操作一段连续的数。如果存在最优解是操作两段数，我们可以只操作其中结果较大的一段。
* 只按从后往前的顺序操作。如果存在最优解不是按这个顺序，调整顺序也一定能够操作，从而得到相同的结果。
* 必然操作到下标0才结束。否则，或者它不是最大的数（从而不能继续操作），或者它总是可以继续操作来获得更大的数。

因此我们按从后往前的顺序进行贪心，到了不能操作的时候，放弃掉当前的数

## T3

首先，如果存在一种构造方法，一定可以构造如下的一个目标：

* 第一个分组恰好仅有一个数字
* 第二个分组恰好仅有两个数字
* 以此类推

因为任何一种合法的构造方法都能够通过删去一些元素得到上述构造，因此无需考虑其他构造形式。

### 模拟赛中我的做法

未能找到直接的构造思路，考虑是否可以组成 $k$ 个分组关于 $k$ 是单调的，因此在二分框架下设法进行验证。

考虑如何贪心构造一个解。因为我们仅需找到一组 $k$ 个分组，每组数量分别是 $1,2,3...k$ 的解，因此我们把问题变形为 如何用所有的数字填满一个 三角形的空格。

关键在于如何充分利用较多的数字：

* 最多的一个数字，最多也只能用 $k$ 个（每个分组至多一个）。我们尽量用最多。
* 如果最多的用了k个，第二多的数字最多只能用 $k-1$ 个。同样我们尽量用最多。
* 第三个数字的情况开始变得复杂：
    * 如果前两个数分别用了 $k$ 个和 $k-1$ 个，第三个数仅能用 $k-2$ 个。
    * 但是如果前两个数都只用了 $k-1$ 个，其实第三个数同样能用 $k-1$ 个。

我们可以换一种更简单的方法来表达：

* 考虑数量最多的前 $i$ 个数字，他们总计最多能使用 $\sum_{j=0}^{i-1}(k-j) = ik - \frac{i(i-1)}{2}$ 个数字（因为每个分组都不超过 $i$ 个不同的数字）

因此考虑第 $i$ 个数字时我们只开放 $i$ 列格子。我们可以通过如下贪心构造方法来证明一定可以得到上述数量的一组解：

* 填数时，永远往总剩余格子最多的行内进行填充。

形象的理解，把后i个数排成阶梯，多余的数总是可以向右上方补齐到上方空缺的位置里，但不能向左补齐（否则会一行出现重复元素）

### 换个角度的O(n)贪心

仍然考虑排序的顺序，但从小到大考虑。

每次考虑新增一列，若足以延续当前阶梯，则延续（多余的数保留）

若不足以延续当前阶梯，考虑上方的空缺和之前的多余，总会存在一种方案将之前的多余补齐到上方的空缺中，因为数组是排过序的，空缺每列最多多出一个，多余的数也是从1个开始逐步递增的。当空缺总和比多余总和少的时候，最大同行的空缺数量，一定少于不同的多余的数的数量。

因此可以直接在排序后的数组迭代，记录当前的高度和多余的数量。当数量不足产生空缺时，降低高度，同时释放出的余量刚好等于当前的高度。

因为排序过程仅需考虑数字最大为 $n$ ，超过 $n$  都可以当 $n$ 处理，所以可以采用 $O(n)$ 的桶排，之后迭代处理，整体复杂度 $O(n)$ 。

