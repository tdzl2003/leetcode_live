[比赛链接](https://leetcode.cn/contest/weekly-contest-347/)

## T1

简单题，按题意找到截取的位置 进行一次性截取即可。

大部分语言的string实现中，一个个截取/pop_back 也是可以通过本题的

## T2

简单题，按题意模拟即可通过本题，复杂度 $O(N*M*min(N,M))$

注意到对每条对角线，可以采用连续迭代计算，先统计出 `topLeft[r][c] - bottomRight[r][c]` ，最后一次性对所有答案取绝对值。这样可以在 $O(N*M)$ 时间解决本题。

## T3

简单思路题

注意到以下事实：

* 相邻的不同字母必然带来一次操作
* 每次操作至多减少一对“相邻的不同字母”，且总是可以减少一对相邻的不同字母

因此对每个相邻的不同字母进行一次操作。从左侧操作或从右侧操作均可，取其中代价较小的即可。

## T4

DP&复杂度优化题。

注意到只能前往严格大于当前单元格的值，因此按照单元格的值排序即构成DAG，可以进行DP。

如果直接扫描每行所有值，最坏情况会达到 $O(NM(N+M))$ 的复杂度，在极端数据下退化到 $N^2$ 或 $M^2$ 则可能导致超时。

注意到每一行的DP值一定随着值增大而单调增大（因为存在路径），因此我们只需要关注值比当前小的最大的值即可。但注意到表格中有相同的值，相同的值需要排除。可以采用以下方法之一：

* 记录每行、每列最大的两个值：
    * 如果当前值和最大的值相同，则取倒数第二大的值进行计算
    * 维护时，如果和最大的值相同，则更新它的DP值，否则滚动数组。
* 用两个数组；用A数组记录不包含当前值的记录，B数组记录包含当前值的记录；连续处理一批相同的值，再将他们的值集体更新上去。注意应当仅更新DP值发生了改变的行/列（脏标记+更新列表），否则复杂度仍然会超。

综上可以将DP复杂度压缩到 $O(NM)$ ，考虑前面的排序过程，复杂度 $O(NM\times lg(NM))$，足以通过本题。
