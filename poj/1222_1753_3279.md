# 开关灯问题

三个开关灯问题同讲

题目链接：[1222](http://poj.org/problem?id=1222)， [1753](http://poj.org/problem?id=1753)，[3279](http://poj.org/problem?id=3279)

昨天我们在讲斐波那契数列的时候讲到了用“矩阵”来解决线性递推式，其中顺带提到了我们可以在计算过程可以应用同余定理，在每次运算后取模，来避免大整数运算（很多涉及到 mod 10^9+7 的题都需要用同余定理）。

今天这题则我们从矩阵分析的过程中就把同余考虑在内。

## 基础思路

一个基础的思路是枚举第一行的所有操作，之后我们就可以通过第一行灯的状态来确定之后每一格的操作组合，判断是否达到目标状态，从而完成$\Theta(2^N * N * M)$时间复杂度的算法。

## 同余矩阵/异或矩阵

我们注意到开关灯的每个操作，是对一系列灯的状态取反（0 变 1,1 变 0）。取反还可以换一种理解：

```c++
not x == x xor 1 == (x + 1) mod 2
a and b => (a \* b) mod 2 前提是 $ a,b \in [0, 1] $
```

取反可以理解成异或 甚至是模 2 的加法。

而 AND 则可以理解模 2 的乘法

那么设 S 为初始状态，R 为目标状态，我们把所有状态的开关状态用 0、1 表示

```
S = 111001010101010000100101

R = S
    xor 0 * 110000100000000000000000
    xor 1 * 111000010000000000000000
    xor 0 * .
    xor 0 * .
    xor 1 * .
    xor 0 * .
    xor 1 * .
    xor 0 * .
    xor 0 * .
```

其中乘号前的 0、1 表示是否在某一个位置上做操作。而乘号后面的串，则表示该位置上做操作影响到哪些格子（影响的为 1，不影响的为 0）

因此这个式子也可以表达成同余矩阵乘法：

```
A * M = B
```

其中 A 是每个格子是否做操作的向量，M 是每个位置操作影响到哪些位置的矩阵，B 是起始状态和目标状态之间的差异（不同为 1，相同为 0）

因此问题转化为：已知 M 和 B 求 A

## 思路一：（适用 1222）

假设$M$的逆矩阵为$M^{-1}$

$$
M * M^{-1} =  M^{-1} * M = I \\
A * M = B  \\
A = A * M * M^{-1} = B * M^{-1}
$$

如果我们能求出$M^{-1}$，那么我们可以直接得出结果。

高斯消元法：应用一系列的操作，将$[M, I]$的左侧变成$I$

> 应用一系列的操作需要等价于左乘上一系列的矩阵

$$
A*B*C*D * \begin{bmatrix}M&I\end{bmatrix} \\
=  M^{-1} * \begin{bmatrix}M&I\end{bmatrix} = \begin{bmatrix}I&M^{-1}\end{bmatrix}
$$

我们可以应用这两个操作

- 操作 1：某行异或上另一行
- 操作 2：交换两行

> 这两个操作都可以等价于左乘一个矩阵。至于是什么样的矩阵？自己想想看。

$$
\begin{bmatrix}
1 & 1 & 1 & 0 \\
0 & 1 & 0 & 1 \\
\end{bmatrix}

\\=> \\
\begin{bmatrix}
1 & 0 & 1 & 1 \\
0 & 1 & 0 & 1 \\
\end{bmatrix}

\\因此有：\\
\begin{bmatrix}
1 & 1\\
0 & 1\\
\end{bmatrix} ^{-1} = \begin{bmatrix}
1 & 1\\
0 & 1\\
\end{bmatrix}
$$

对于 1222，我们就可以直接预先求出逆矩阵从而完成一次向量乘矩阵运算之后即可直接输出结果。

## 思路二：适用 3279

注意线性同余不是所有的矩阵都有逆矩阵，例如：

$$
\begin{bmatrix}
1 & 1 & 1 & 0 \\
1 & 1 & 0 & 1 \\
\end{bmatrix}
\\=> \\
\begin{bmatrix}
1 & 1 & 1 & 1 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

无法通过高斯消元将左半边变形成单位矩阵。事实上，这意味着矩阵不“满秩”。

> 注意不同于实数矩阵，整数同余矩阵如果模的数不是质数，一个矩阵即使满秩也可能会没有逆矩阵，如矩阵的一个行或列上的所有元素都和模的数不互质，直观的例子是，你找不到任何一个正整数 k 满足 (2\*k) mod 4 = 1，所以[2]这个 1\*1 的矩阵在 mod 4 运算下就不可逆。但这类情况对于 mod 2 不会出现。

如果高斯消元法得不到单位矩阵（不满秩）：

- r(M) = r([M, B])：多组解。实数矩阵这种情况意味着无穷多组解，但对于整数同余矩阵是有限多组解。所有的解=特解+若干自由基的任意组合（通解）
- r(M) < r([M, B])：无解。

此时我们消元对于能够留下对角矩阵的列，将其它的行都变为 0。不能留下对角矩阵的列，总是可以将该行**完全清 0**，但列上留下不同位置的若干个 1。

这时候，常量列（最右列）的值，即为一组特解。这解释为，所有的“自由元”都取 0，那么只剩下对角矩阵的一部分，A 向量的对应行则等同于消元后最右列的值。

而不能留下对角矩阵的列，该列所有的值，再加上自由元自身的下标对应的 1，则为一组通解。这解释为，如果一个自由元要取 1，那么在矩阵中该列为 1 的每一行，意味着受到了该自由元的影响，要同步切换状态（相当于加 1），因此相当于在特解的基础上，加上一个该列的值 再加上 该自由元自己。

例如我们消元后的结果是：

$$
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 1 & 1 \\
0 & 0 & 0 & 0 \\
\end{bmatrix}
$$

那么：特解是 010，自由基是 011（第三列的 010 加上代表第三列的自由元 001），该方程的两组解分别是 010 和 001

因此 3279 我们完全应用这种标准的高斯消元解方程法，首先检查是否出现 r(M) < r([M, B])，直接返回无解；然后可以求出特解和自由基，并对比自由基的每一种组合，寻找操作次数最少（1 的个数最少）的一种，并返回。

## 思路三：适用 1753

对于 4\*4 的情形，我们恰好能够计算出矩阵的秩为 16，有解的情况有 4 个自由元，并且我们能够通过高斯消元，将这 4 个自由元安排在第一排（或最后一排）。因此这意味着对于 4\*4 的情形，恰好第一排就可以作为所有的自由元。因此我们可以更 hack 一点：

- 首先假设第一排完全不操作，直接应用*基础思路*提供的方法，计算出一组通解，或判定无解
- 然后我们用预计算好的自由基，直接完成组合，寻找最少操作的一种方法。这个预先计算可以通过消元得到，也可以同样使用*基础思路*来得到。

因此这题我们仅仅使用矩阵给我们提供结论（自由元的个数），剩下的代码可以完全用基础思路来完成。
